# beget

[Официальная документация](https://beget.com/ru/kb/how-to/web-apps/python)

---

## Получить хостинг

https://beget.com/ru/hosting/virtual

## Подключиться к хостингу по SSH

Включить доступ по SSH (Нужно привязать номер телефона)

![](_attachments/4b357adc00b050a1bf17c9fc0407c6c1.png)

---

Подключиться по SHH. Ввести логин, сервер, пароль

```bash
shh Login@IP
```

- `Login` Логин
- `Ip` Сервер

Ввести пароль который вам вышлют на почту

> ![](_attachments/dd563e8b933189e6948e3db6134ed000.png)

Потом необходимо войти в `Docker`.(Он спросит пароль)

```bash
ssh localhost -p222
```

---

## Подключится по FTP

Нужно создать FTP-Аккаунт
![](_attachments/519bbb17a9a105d8cfb2570321c81c81.png)

Нужно ввести Логин, Сервер, Пароль. **Порт 21**
![](_attachments/9b0d4b9acddf88318f9dc49bd78e9619.png)

## Установка `Python`

Сначала необходимо войти в `Docker`.(Он спросит пароль)

```bash
ssh localhost -p222
```

Создать папку со временными файлами

```bash
mkdir -p ~/.beget/tmp && cd ~/.beget/tmp
```

Скачать компилятор, распаковать архив, удалить архив, перейти в папку

```bash
wget ftp://sourceware.org/pub/libffi/libffi-3.2.1.tar.gz && tar -xf libffi-3.2.1.tar.gz && rm -r libffi-3.2.1.tar.gz && cd libffi-3.2.1
```

Настройка конфигурации, компиляция, установка

```bash
./configure --prefix $HOME/.local LDFLAGS="-L/usr/local/lib" && make -j33 && make install
```

Копируем файлы в `include`

```bash
mkdir -p ~/.local/include &&  cp x86_64-unknown-linux-gnu/include/ffi.h ~/.local/include/ && cp x86_64-unknown-linux-gnu/include/ffitarget.h ~/.local/include/
```

Скачиваем исходники `python`, разархивируем, удаляем архив (Можно выбрать другую версию Python)

```bash
cd ~/.beget/tmp &&  wget https://www.python.org/ftp/python/3.8.2/Python-3.8.2.tgz && tar -xf Python-3.8.2.tgz && rm -r Python-3.8.2.tgz && cd Python-3.8.2
```

Настраиваем, компилируем `python`, проверим

```bash
./configure --prefix=$HOME/.local LDFLAGS="-L/usr/local/lib" && make -j33 && make install && ~/.local/bin/python3.8 -V
```

Проверим работоспособность

```bash
python3.8
```

---

Установить общий доступ к папке `.local` [+](https://sprutio.beget.com/)

- ![](_attachments/7fac66226af3e82b7e603f3bcbc38712.png)
- ![](_attachments/8eea845c940a8c937f474085f9c0dcbf.png)

---

## Создать виртуальное окружение

`venv` нужно располагать в папке с именем `Сервер` (`deniskl4.beget.tech`) (Чтобы проверить путь к ВО `which python`)

```bash
python3.8 -m venv <ИмяВО>
```

Скачать все необходимые зависимости. (Лучше заранее создать файл `requirements.txt`и хранить его вмести с проектом на `GitHab`)

```bash
pip3 install -r requirements.txt
```

## Скачать проект

Разместите свой сайт на `GitHab`, а потом просто скачайте его на сервер командой

```bash
git clone <URL_Вашего проета>
```

![](_attachments/22cc19b335d7390de8de45c223c78779.png)

## Настроить Djang

Помощник для оформления `passenger_wsgi.py` `.htaccess `. Файл должен находится в папке сервера `/home/d/<Имя>/<Сервер>.beget.tech`.

```python
import os
import site
import sys

catpath = lambda _index=-1: "/".join(os.path.abspath(__file__).split("/")[:_index])


def init_beget(_name_path):
    """
    python ...py init HelloDjango
    """

    passenger_wsgi = f"""
import os, sys
sys.path.insert(0, '{catpath(-1)}/{_name_path}')
sys.path.insert(1, '{site.getsitepackages()[0]}')
os.environ['DJANGO_SETTINGS_MODULE'] = '{_name_path}.settings'
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()
"""[1:]

    htaccess = f"""
PassengerEnabled On
PassengerPython {sys.executable}
"""[1:]
    print("\nОбратите внимание каким интерпретатором вы запустили код!\n")
    print("\n<passenger_wsgi.py>\n", passenger_wsgi)
    print("<.htaccess>\n", htaccess)

    res = input("Все верно ? Y/n  ")

    if res == "y" or res == "Y":
        with open("passenger_wsgi.py", "w") as _file:
            _file.write(passenger_wsgi)
        with open(".htaccess", "w") as _file:
            _file.write(htaccess)
        print("Не забудьте изменить имя хоста в settings.py")
    else:
        print("Файлы не созданы")


if __name__ == '__main__':
    """
    chmod +x ./<myscript>
    ./<myscript>
    """
    _request = sys.argv

    if _request[-1] == "docker":  # Активировать Docker
        print("ssh localhost -p222")


    elif _request[-1] == "venv":  # Активировать ВО
        print(f". {catpath()}/venv/bin/activate && which python")

    elif len(_request) == 3 and _request[-2] == "set":  # Настроить переадресацию
        # python ...py init HelloDjango
        name_path = _request[-1]
        init_beget(name_path)

    elif _request[-1] == "help":
        print("docker = Активировать Docker\n"
              "venv =  Активировать ВО\n"
              "set <ИмяПроектаDjango> = Настроить переадресацию\n")

    else:
        print("Неизвестная команда")
```

Допустим у него будет название `helpr.py`. Тогда необходимо запустить таким образом.

```bash
pythno3.8 helper.py <ИмяПроекта>
```

---

Пример `pythno3.8 helper.py HelloDjango`

`passenger_wsgi.py`

```python
import os, sys
sys.path.insert(0, '/home/d/deniskl4/deniskl4.beget.tech/HelloDjango')
sys.path.insert(1, '/home/d/deniskl4/deniskl4.beget.tech/venv/lib/python3.8/site-packages')
os.environ['DJANGO_SETTINGS_MODULE'] = 'HelloDjango.settings' # обратите внимание что название главного приложения может отличатся от папки, если это так то сделайте имена одинаковые.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()
```

`.htaccess`

```bash
PassengerEnabled On
PassengerPython /home/d/deniskl4/deniskl4.beget.tech/venv/bin/python3.8
```

---

Добавить хостинг в программе`settings.py`

```python
ALLOWED_HOSTS = ["Сервер"]  # Указать свое имя сервера
```

---

Создать `restart.txt`

```bash
cd ~/<Сервер>/ && mkdir tmp; touch tmp/restart.txt
```

---

Для корректной отдачи статического контента средствами **Nginx** создается симлинк на **public_html**:

```bash
ln -s public_html public
```

# Яндекс облако

[Создадим виртуальна машину](https://console.cloud.yandex.ru/folders/b1gsrodsa6ckfimjd5km/compute?section=instances)

## Оформляем сервер

- ![Логин и ssh клчю](_attachments/7b261df0dd531a480b2d88636a85bee7.png)
    > -   Логин можно придумать любой,
    > -   ssh ключ, если у вас его нет ключа то можно сгенерировать командной `ssh-keygen`, а потом получить командой `cat ~/.ssh/id_rsa.pub`(Это нужно для удаленного подклчения к серверу по ssh)
- ![Создать платежный аккаунт](_attachments/5563c991708beaf26069e8da4d2d6e8a.png)

    > -   Нужно добавить банковскуб карту с 11 рублями на счету

- ![Заходим в настройки ВМ](_attachments/856a4b952cb8e9d7921f9843004cf12c.png)

    > -   Копируем публинчый IP адрес

- Заходим на север через `ssh Логин@ПубличныйIPv4`

# Настраиваем сервер

[Пример](https://github.com/alexey-goloburdin/debian-set-up-for-django)

1.  Установить пароль супер пользователя.
    ```bash
    sudo passwd root
    ```
1.  И установить пароля для пользователя

    ```bash
    sudo passwd ВАШ_ПОЛЬЗОВАТЕЛЬ
    ```

1.  Установка необходимый программ

    ```bash
    sudo apt update ; \
    sudo apt install -y vim tmux vsftpd openssh-server htop tree git zsh nginx  curl wget \
    python3-pip python3-dev libpq-dev \
    unzip zip gcc net-tools redis-server build-essential make \


    ```

1.  Скачиваем `PostgreSQL`

    ```bash
     sudo apt install postgresql postgresql-contrib
    ```

1.  Скачиваем `python` и ВО

    ```bash
    sudo apt install python3.9 python3.9-venv
    ```

1.  Создаем ВО
    ```bash
     python3.9 -m venv ~/venv_django
    ```
1.  Скачиваем проект

    ```bash
    git clone
    ```

    > Можно воспользоваться [Скрипт для авто настройки Расположите этот файл в одной папке с manage py](#Скрипт%20для%20авто%20настройки)

1.  Настраиваем `gunicorn`. И настраиваем его [Настройка gunicorn](#Настройка%20gunicorn)

1.  Настраиваем `nginx`. [Настройка Nginx](#Настройка%20Nginx)

1.  Настраиваем `systemd` для `Gunicorn` [Настраиваем systemd для Gunicorn](#Настраиваем%20systemd%20для%20Gunicorn)

---

1.  Настраиваем `FTP` [FTP](../Уроки/Блок6%20-%20Сети.md#FTP)
2.  Настраиваем `vim` [Быстрая настройка vim](../Знания/Программы%20для%20Linux.md#Быстрая%20настройка%20vim)
3.  Настраиваем `zsh` [Быстрая настройка zsh](../Знания/Программы%20для%20Linux.md#Быстрая%20настройка%20zsh)
4.  Настраиваем `tmux` [Быстрая настройка Tmux](../Знания/Программы%20для%20Linux.md#Быстрая%20настройка%20Tmux)
5.  Настраиваем `mc`[Быстрая настройка mc](../Знания/Программы%20для%20Linux.md#Быстрая%20настройка%20MC)
6.  Локализация `linux` [Локализация - Русский язык](../Знания/Ядро%20Linux.md#Локализация%20-%20Русский%20язык)

---

# `gunicorn`

## Настройка `gunicorn`

Установите `gunicorn` в ваше Виртуальное Окружение

```bash
pip install gunicorn
```

Мы можем использовать `gunicron` самостоятельно без `nginx`, для этого, мы запустим сервера по протоколу `IP`. Мы указываем серверу какой `ip:port` слушать флагом `--bind`, также мы можем указать дополнительные настройки для работы `gunicorn`[+](https://docs.gunicorn.org/en/stable/settings.html#settings).

```bash
gunicorn --bind 0.0.0.0:8090 ИмяГлавногоПриложения.wsgi:application
```

Либо можем запускать `gunicorn` вне виртуального окружения, тогда нужно указать полный путь `gunicorn` который расположен в вашем ВО.

```bash
"/home/Пользователь/ИмяВо/bin/gunicorn" --bind 0.0.0.0:8090 ИмяГлавногоПриложения.wsgi:application
```

> В контексте серверов `0.0.0.0` означает «все адреса IPv4 на локальном компьютере». Если хост имеет два IP-адреса, `192.168.1.1` и` 10.1.2.1`, и сервер, запущенный на хосте, прослушивает `0.0.0.0`, он будет доступен на обоих этих IP-адресах.[+](https://ip-calculator.ru/blog/ask/v-chem-raznitsa-mezhdu-127-0-0-1-i-0-0-0-0/) . Либо мы можем указать явно наш внутренний `ip`, для этого используйте команду `ifconfig`

Для того чтобы не запоминать все настройки для `wsgi`-`gunicorn` , мы можем создать файл конфигураций, обычно его называют `gunicorn.conf.py` и, для того чтобы эти применить конфигурации используйте флаг `--config`. Также мы можем указать полный путь к вашему проекту через флаг `--chdir`. В итоги нам нужно будет только одну команду.

```bash
"/home/Пользователь/venvdjango/bin/gunicorn" \
--config "gunicorn.conf.py" \
--chdir "/home/Пользвоатель/ВашПроект" ИмяГлавногоПриложения.wsgi:application
```

---

Запуск `gunucorn` в `Pycharm`
![Запуск `gunucorn` в `Pycharm` ](_attachments/a6af899c6865f37b3300df2bdcc5fc80.png)

- `<ПутьВО>/venv/bin/gunicorn`
- `--bind 0.0.0.0:8080 <ИмяПроекта>.wsgi:application`
- `<ПолныйПутьК_Проекту>`

---

Ниже приведен пример шаблона `gunicorn.conf.py`.

Файл настроек для запуска `gunicorn`. Храниться обычно под именем`gunicorn.conf.py`. Для запуска сервера с этими настройками используйте команду `gunicorn -c gunicorn.conf.py ИмяГлавногоПриложения.wsgi:application` [Документация](https://docs.gunicorn.org/en/stable/settings.html#settings). [Официальный шаблон](https://github.com/benoitc/gunicorn/blob/master/examples/example_config.py)

```python
import os
import re
from pprint import pprint


def read_env_file_and_set_from_venv(file_name: str):
	"""Чтение переменных окружения из указанного файла, и добавление их в ПО `python`"""
	with open(file_name, 'r', encoding='utf-8') as _file:
		res = {}
		for line in _file:
			tmp = re.sub(r'^#[\s\w\d\W\t]*|[\t\s]', '', line)
			if tmp:
				k, v = tmp.split('=', 1)
				# Если значение заключено в двойные кавычки, то нужно эти кавычки убрать
				if v.startswith('"') and v.endswith('"'):
					v = v[1:-1]
				
				res[k] = v
	os.environ.update(res)
	pprint(res)


### Уточнения
# Путь к файлу с переменными окружения
PATH_ENV = #"/".join(__file__.split('/')[:-3])
# Чтение файла с переменными окружениями и добавление этих данных в ПО  `Python`
read_env_file_and_set_from_venv(os.path.join(PATH_ENV, "__env.env"))
# Слушать указанный ip адрес и порт  '<10.130.0.34:8001>'. Но лучше указать UDS сокет 'unix:/run/gunicorn.sock'
bind = f"0.0.0.0:{os.environ.get('EXTERNAL_WEB_PORT')}"
# Путь к `WSGI` приложению  `ИмяГлавногоПриложения.wsgi:application`
wsgi_app = #'conf.wsgi:application'


### Производительность
# Количество рабочих процессов для обработки запросов. Оптимально установить количество процессов по формуле `2-(4xЯдерЦпу)`
workers = 3
# Этот параметр используется для ограничения количества заголовков в запросе - предотвратить DDOS-атаку.
limit_request_fields = 32000
# Ограничьте допустимый размер поля заголовка HTTP-запроса.
limit_request_field_size = 0
# Максимальное количество одновременных клиентов
worker_connections = 1000

### Другие
# Авто перезагрузка сервера при изменении файлов проекта `Django`
reload = True
# Путь к папке `gunicorn`
ROOT_DIR = #"/".join(__file__.split('/')[:-1])
# Путь для вывода лог данных
#accesslog = f"{ROOT_DIR}/gunicorn_ass.log"  # !!! ПРОВЕРИТЬ ПУТИ ЛОГОВ
# Путь для вывода ошибок
#errorlog = f"{ROOT_DIR}/gunicorn_err.log"  # !!! ПРОВЕРИТЬ ПУТИ ЛОГОВ
```

## `gunicorn` и `nginx`

Однако лучше использовать `gunicorn` в связки с `nginx`. Благодаря перенаправлению (проксированию)`nginx`мы можем запустить наш `wsgi` сервер на `unix socket`. `nginx` будет принимать запросы от клиентов и перенаправлять их на ваш `unix socket`, а статические файлы и медиа будет отдавать самостоятельно без обращения к серверу `wsgi`.

Для того чтобы запустить `wsgi`-`gunicorn` на `unix socket` нам нужно указать в `--bind` `unix:ПутьК_UnixSocket`, название и путь может быть любым, но давайте дадим название нашему сокету `gunicorn.sock`. Вот так мы запускаем наш `wsgi`-`gunicorn` сервер. (Тут также можно использовать файл конфигурацией `gunicotn.conf.py`)

```bash
"/home/Пользователь/venvdjango/bin/gunicorn" \
--bind  "unix:/home/Пользователь/gunicorn.sock" \
ИмяГлавногоПриложения.wsgi:application
```

В конфигурациях `nginx` по пути `/etc/nginx/sites-enabled/ЛюбоййФайл` добавим правило маршрутизации, в нашем случае мы перенаправляем (проксируем) на `unix socket` который работать по протоколу `http`. Поэтому шаблон будет выглядеть так `proxy_pass http://unix:ПутьК_UnixSocket`

```bash
server {
    listen 80 default_server;

    # Задаёт максимально допустимый размер тела запроса клиента.
    client_max_body_size 4G;

    location = /favicon.ico { access_log off; log_not_found off; }

    # Раздача статических файлов
    #location /static/ { 
    #        root ${WORK_DIR}/${NAME_PROJ}/${NAME_PROJ};
    #}
    # Разадча медиа файлов
    #location /media/ {
    #        root ${WORK_DIR}/${NAME_PROJ}/${NAME_PROJ};
    #}

    # Перенаправление на наш `WSGI` сервер
    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        # Настройка для контейнера с именем `web`
        #proxy_pass http://web:${EXTERNAL_WEB_PORT};
        proxy_pass http://unix:<ПутьК_UnixSocket>;
    }
}
```

## Настраиваем `systemd` для `Gunicorn`

`systemd` - подсистема инициализации и управления службами в Linux. Она нам пригодится для автоматического запуска нашего сервера, при перезагрузке системы.

- Создаем файл для обслуживания и контроля `unix socket` на котором запуститься `wsgi` - `gunicorn` [`systemd.socket` - Конфигурация сокета](https://www.freedesktop.org/software/systemd/man/systemd.socket.html)

    ```bash
    sudo vim /etc/systemd/system/gunicorn.socket
    ```

    ```bash
    [Unit]
    	# Описание.
    Description=gunicorn socket
    [Socket]
    	# Слушаем UDS сокет.
    ListenStream= </run/gunicorn.sock: Ваш путь к сокету>
    [Install]
    WantedBy=sockets.target
    ```

- Создаем управляющий файл. `sudo systemctl status gunicorn.service` == `sudo systemctl status gunicorn` мы можем не указывать расширение `.service` потому что это одно и тоже. [`systemd.service` Конфигурация служебного блока](https://www.freedesktop.org/software/systemd/man/systemd.service.html)

    ```bash
    sudo vim /etc/systemd/system/gunicorn.service
    ```

    ```bash
    [Unit]
    	# Описание.
    Description=gunicorn daemon
    	# Зависит от сокета.
    Requires=gunicorn.socket
    	# Запустить сервер после (сетевой карты).
    After=network.target
    	# Настройка запска
    [Service]
    	# Имя пользователя от которого будет запущен процесс.
    User=<ИмяПользователя>
    	# Имя группы от которого будет запущен процесс (Если группы нет то укажите имя пользователя).
    Group=<ИмяГруппы>
    	# Путь к проекту.
    WorkingDirectory=<>
    	# Скрипт котоырй нужно выполнить при старте системы.
    ExecStart=<>
    	# Перезапускать сервер при ошибках
    Restart=on-failure
    [Install]
    	# При каких обстоятельствах должен быть запущен сервис.
    	# `WantedBy=multi-user.target` устанавливает запуск при обычной загрузке компьютера.
    WantedBy=multi-user.target
    ```

---

- Посмотреть журнал
    ```bash
    sudo journalctl -xeu gunicorn.socket
    ```
    ```bash
    sudo journalctl -xeu gunicorn
    ```
- Перезагрузить все службы
    ```bash
    sudo systemctl daemon-reloa
    ```
- Запустить сервис
    ```bash
    sudo systemctl start gunicorn.socket
    ```
    ```bash
    sudo systemctl start gunicorn
    ```
- Добавить в авто заупск сервис
    ```bash
    sudo systemctl enable gunicorn.socket
    ```
    ```bash
    sudo systemctl enable gunicorn
    ```


# `Nginx`

`Nginx` - прокси-сервер, используется для [+](https://nginx.org/ru/)

- Распределение нагрузки и отказоустойчивость;
- Для выдачи статических и меда файлов. (Обслуживание статических запросов)
- Модульность, фильтры, в том числе сжатие (`gzip`), byte-ranges (докачка), chunked ответы, XSLT-фильтр, SSI-фильтр, преобразование изображений;
- Поддержка SSL и расширения TLS SNI;
- Ограничение скорости отдачи ответов;
- Ограничение числа одновременных соединений и запросов с одного адреса;
- Проксирование TCP и UDP;
- Ограничение доступа в зависимости от адреса клиента;
- Выполнение разных функций в зависимости от адреса клиента;

## Настройка `Nginx`

Все файлы из `/etc/nginx/sites-enable` подключаются в главный `/etc/nginx/nginx.conf`. Поэтому нам достаточно отредактировать `/etc/nginx/sites-enabled/default`

```bash
server {
    listen ${NGINX_PORT} default_server;

    # Задаёт максимально допустимый размер тела запроса клиента.
    client_max_body_size 4G;

    location = /favicon.ico { access_log off; log_not_found off; }

    # Раздача статических файлов
    #location /static/ { 
    #        root ${WORK_DIR}/${NAME_PROJ}/${NAME_PROJ};
    #}
    # Разадча медиа файлов
    #location /media/ {
    #        root ${WORK_DIR}/${NAME_PROJ}/${NAME_PROJ};
    #}

    # Перенаправление на наш `WSGI` сервер
    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        # Настройка для контейнера с именем `web`
        proxy_pass http://web:${EXTERNAL_WEB_PORT};
        # proxy_pass http://unix:ПутьК_UnixSocket;
    }
}
```

---

Протестировать конфигурацию `ngix`. Если етсь ошибки они выведутся в консоль.

```bash
sudo nginx -t -c /etc/nginx/nginx.conf
```

Перезагрузить `ngix`(При изменение настроек `nginx` нужно его перезагрузить)

```bash
sudo systemctl restart nginx.service
```

---

## Описание

![`ngix` сервер и слушатель](_attachments/d21cb2ab2a1513443753a5ab40a9c748.png)

`/etc/nginx/nginx.conf`

```bash
# !!! Обязательно указать своего имя пользователя
user <ИмяПрользователя>;

worker_processes 1;
events {
  worker_connections  1024;
}


http {
    # common http settings
    # Копироание файлов без буфиризации
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;

    # максимальное время соединения
    keepalive_timeout 65;
	types_hash_max_size 4096;



	include /etc/nginx/mime.types;
	default_type application/octet-stream;



    access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log;

    gzip on;

	#include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}

```

`/etc/nginx/sites-enabled/...`

```bash
server {
    listen 80 default_server;

    # Задаёт максимально допустимый размер тела запроса клиента.
    client_max_body_size 4G;

	location = /favicon.ico { access_log off; log_not_found off; }



    location /static/ {
            root /home/denis/PycharmProjects/testvpn/experement;
    }
    location /media/ {
            root /home/denis/PycharmProjects/testvpn/experement;
    }

    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_pass http://unix:/home/denis/PycharmProjects/testvpn/experement/gunicorn/gunicorn.sock;
    }
}
```

---

`worker_processes` = эта настройка описывает число рабочих процессов, которые сервер будет использовать. Поскольку NGINX является однопоточным, это число обычно эквивалентно количеству ядер процессора.

`worker_connections` = максимальное число одновременных подключений для каждого worker_processes, оно сообщает, сколько людей одновременно NGINX сможет обслужить. Чем это число больше, тем больше запросов пользователей сможет обработать веб-сервер.

`access_log` и `error_log` = это файлы, которые сервер использует для логирования всех ошибок и попыток входа. Эти логи нужно в первую очередь проверять при возникновении проблем и при поиске неисправностей. (**Их нужно создать зарание**)

> ```bash
> error_log /var/log/nginx/error.log;
> access_log /var/log/nginx/access.log;
> ```

`gzip` = это свойство устанавливает настройки сжатия GZIP для NGINX ответов.

---

`listen` = Правила для указанного порта. `listen <Порт> default_server` указывает что этот порт главный, и если есть несколько сервера слушающий один и тот же порт, выберется сервер с аргументом `default_server`.

`proxy_pass`= запрос будет отправлен на указанный сервер.

`root`= Задаёт корневой каталог для запросов.

`alias` = Задаёт замену для указанного location’а. Например, при такой конфигурации

`keepalive_timeout` = Первый параметр задаёт таймаут, в течение которого keep-alive соединение с клиентом не будет закрыто со стороны сервера. Значение 0 запрещает keep-alive соединения с клиентами.

`client_max_body_size` = Задаёт максимально допустимый размер тела запроса клиента.

`types_hash_max_size` = Задаёт максимальный размер хэш-таблиц типов. Подробнее настройка хэш-таблиц обсуждается в отдельном

`user` указать под каким юзером будут заходить пользователи. (**Если не указать возможно ошибка 403**)

---

- [Модули и детективы](https://nginx.org/ru/docs/http/ngx_http_core_module.html#root)
- [Проксирование](https://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_pass)
- [Особые функции](http://nginx.org/ru/docs/ngx_core_module.html#accept_mutex)

# Скрипт для авто настройки.

Настройка `gunicorn`,`nginx`. **Расположите этот файл в одной папке с `manage.py`**. [+](https://gist.github.com/denisxab/7730eec6e2d7daad6aa6d4aa44f93609)

```python
"""
# Запускать скрипт нужно от рута, и из ВО окружения которое должно вязаться для проекта.
sudo /home/ИмяПользователя/bin/python3.9 init.py


# Полезные команды
sudo systemctl daemon-reload

sudo systemctl restart gunicorn.socket
sudo systemctl restart gunicorn

sudo systemctl status gunicorn.socket
sudo systemctl status gunicorn

sudo systemctl start gunicorn.socket
sudo systemctl start gunicorn

sudo journalctl -u  gunicorn.socket > t.xt; cat t.xt
sudo journalctl -u  gunicorn > t.xt; cat t.xt

curl --unix-socket /home/denis/PycharmProjects/testvpn/experement/gunicorn/gunicorn.sock localhost
"""
import os
from os import path, listdir
from os import system
from re import sub
from sys import executable
from typing import Optional

try:
	from jinja2 import Template
except ImportError:
	os.system("pip install Jinja2")


class DevOps:
	"""


	sudo systemctl status gunicorn
	sudo systemctl status gunicorn.socket


	sudo journalctl -u  gunicorn > t.xt; cat t.xt
	"""
	venv_bin_gunicorn: object
	path_folder_gunicorn: str
	path_gunicorn_access: str
	path_gunicorn_error: str
	path_gunicorn_sock: str
	path_gunicorn_conf_py: str

	def __init__(self,
	             username: str = "",
	             host: str = "",
	             name_proj: str = "",
	             bind: str = "",
	             ):

		# Проверка что скрипт запущен через `root`
		if os.getuid() != 0:
			raise PermissionError(
					"Вы не `root`!\nПопробуйте выполнить код в виде\nsudo /home/ИмяПользователя/bin/python3.9 init.py")

		# Информация
		print(f"Файл:{__file__}")
		print(f"Путь к ВО(Внимание указывайте полный путь к ВО !!!):{executable}\n")

		# Имя пользователя
		self.username = username if username else input("Введите пользователя: ")
		# Разрешенный хост
		self.host = host if host else input("Введите имя хоста: ")
		# Имя приложения, в котором находится файл `setting.py`
		self.name_proj = name_proj if name_proj else self.SearchMainAppDjango()
		# Путь к настройкам проекта
		self.path_settings = f"{path.dirname(__file__)}/{self.name_proj}/settings.py"
		# Путь к проекту
		self.path_proj = path.dirname(__file__)

		# Путь к скриптам `gunicorn`
		self.venv_bin_gunicorn = os.path.split(executable)[0] + "/gunicorn"
		# Путь к папке с нашими настройками  `gunicorn`
		self.path_folder_gunicorn = f"{self.path_proj}/gunicorn/"
		# Логи `gunicorn`
		self.path_gunicorn_access = self.path_folder_gunicorn + "gunicorn_access.log"
		# Ошибки `gunicorn`
		self.path_gunicorn_error = self.path_folder_gunicorn + "gunicorn_error.log"
		# Путь для сокета `gunicorn`
		self.path_gunicorn_sock = self.path_folder_gunicorn + "gunicorn.sock"

		# На каком ("ip:порту")("unix:{path}") будет работать сервер
		self.bind = f"unix:{self.path_gunicorn_sock}"

	def main(self):
		# Установить первоначальные пакеты?
		if self.Input("?: Установить первоначальные пакеты?"):
			self.SetupSelf()

		# Изменить домен в `setting.py->ALLOWED_HOSTS` на `self.host`
		if self.Input("?: Изменить settings.py->ALLOWED_HOSTS на `*`?"):
			self.ChangeALLOWED_HOSTS()

		# Установить зависимости
		if self.Input("?: Выполнить команду `pip install -r requirements.txt`?"):
			self.InstallRequirements()

		# Собрать статически файлы `Django`
		if self.Input("?: Собрать статически файлы `Django`?"):
			system("./manage.py collectstatic")

		# Создать `gunicorn/gunicorn.conf.py`?
		if self.Input("?: Создать `gunicorn.conf.py`?"):
			self.SetupGunicorn()

		# Создать `/etc/nginx/sites-enabled/...`?
		if self.Input(f"?: Создать `/etc/nginx/sites-enabled/{self.name_proj}_nginx`?"):
			self.SetupNginx()

		# Удалить `/etc/nginx/sites-enabled/default`?
		if self.Input(f"?: Удалить `/etc/nginx/sites-enabled/default`?"):
			if os.path.exists("/etc/nginx/sites-enabled/default"):
				os.remove("/etc/nginx/sites-enabled/default")
			else:
				print("Файл не существует")

		# Создать настройки для `systemd`
		if self.Input("?: Создать настройки для `systemd`"):
			self.SetupSystemd()

		if self.Input("?: Настроить `systemctl`?"):
			# Перезагружаем все службы
			system("sudo systemctl daemon-reload")
			# Запускам службы `gunicorn.socket` и `gunicorn`
			system("sudo systemctl restart gunicorn.socket")
			system("sudo systemctl restart gunicorn")
			# Добавляем в авто загрузку `gunicorn.socket` и `gunicorn`
			system("sudo systemctl enable gunicorn.socket")
			system("sudo systemctl enable gunicorn")

	#
	def SetupGunicorn(self):
		"""Настройка `gunicorn`"""

		"""
		mange.py
		- gunicorn
			- gunicorn.conf.py (Спрашиваем)
			- gunicorn_access.log (Не спрашиваем)
			- gunicorn_error.log (Не спрашиваем)
			- gunicorn.sock (Указать только путь, сам сокет файл не нужно создавать, но создаст `systemctl` )
		"""

		os.makedirs(self.path_folder_gunicorn, exist_ok=True)
		_access_log = open(self.path_gunicorn_access, "a").close()
		_error_log = open(self.path_gunicorn_error, "a").close()

		path, res = self.TemplateGunicornConfPy()
		print(f">>>{path}{res}\n")
		if self.Input("Записать шаблон ?"):
			self.save_file(path, res)
		# Поменять  пользователя и группу ` `root` на `self.username`. Разрешить  читать писать и исполнять этот файл !!!
		system(
				f"sudo chown -R {self.username}:{self.username} {self.path_folder_gunicorn} && sudo chmod -R 777 {self.path_folder_gunicorn}")

		self.path_gunicorn_conf_py = path

	def SetupNginx(self):
		path, res = self.TemplateNginxSitesEnabled()
		print(f">>>{path}{res}\n")
		if self.Input("Записать шаблон ?"):
			self.save_file(path, res)
		self.pathNginx = path

	def SetupSystemd(self):
		res1, res2 = self.TemplateSystemd
		print(f">>>{res1[0]}{res1[1]}\n")
		if self.Input("Записать шаблон?"):
			self.save_file(res1[0], res1[1])

		print(f">>>{res2[0]}{res2[1]}\n")
		if self.Input("Записать шаблон?"):
			self.save_file(res2[0], res2[1])

	def SetupSelf(self):
		"""Установить первоначальные пакеты"""
		system("pip install gunicorn Pillow Django psycopg2-binary")
	#
	#
	@property
	def TemplateSystemd(self):
		res1 = """
[Unit]
Description=gunicorn socket
[Socket]
ListenStream={path_gunicorn_sock}
[Install]
WantedBy=sockets.target
		""".format(path_gunicorn_sock=self.path_gunicorn_sock)

		"""
		[Unit]
		Description=gunicorn daemon
		Requires=gunicorn.socket
		After=network.target

		[Service]
		User=denis
		Group=denis
		WorkingDirectory=/home/denis/PycharmProjects/testvpn/experement
		ExecStart=/home/denis/PycharmProjects/testvpn/venv/bin/gunicorn -c "/home/denis/PycharmProjects/testvpn/experement/gunicorn.conf.py" experement.wsgi:application

		[Install]
		WantedBy=multi-user.target
		"""

		res2 = """
[Unit]
Description=gunicorn daemon
Requires=gunicorn.socket
After=network.target

[Service]
User={username}
Group={username}
WorkingDirectory={path_proj}
ExecStart={venv_bin_gunicorn} -c "{path_gunicorn_conf_py}" {wsgi}
Restart=on-failure

[Install]
WantedBy=multi-user.target
		""".format(username=self.username,
		           path_proj=self.path_proj,
		           venv_bin_gunicorn=self.venv_bin_gunicorn,
		           path_gunicorn_conf_py=self.path_gunicorn_conf_py,
		           wsgi=f"{self.name_proj}.wsgi:application", )

		return ("/etc/systemd/system/gunicorn.socket", res1), \
		       ("/etc/systemd/system/gunicorn.service", res2)

	def TemplateGunicornConfPy(self):
		"""
		Создать файл `gunicorn.conf.py`
		"""

		res_gunicorn_conf_py = Template("""
reload=True # Для продакшина лучше False
command = "{{ command }}"
pythonpath = "{{ pythonpath }}"
bind = "{{ bind }}"
workers = 3
user = "{{ user }}"
limit_request_fields = 32000
limit_request_field_size = 0
raw_env = ["{{ raw_env }}",]
accesslog = "{{ path_gunicorn_access }}"
errorlog = "{{ path_gunicorn_error }}"
	""").render(
				command=self.venv_bin_gunicorn,  # Путь у `gunicorn`
				pythonpath=path.split(__file__)[0] + f"/{self.name_proj}",  # Путь к главному приложению проекта
				bind=self.bind,  # Работаем на порту/сокету
				user=self.username,  # Пользователь
				path_gunicorn_access=self.path_gunicorn_access,  # Путь для логов
				path_gunicorn_error=self.path_gunicorn_error,  # Путь для исключений
				raw_env=f"DJANGO_SETTINGS_MODULE={self.name_proj}.settings",  # Данные в переменные окружения
		)
		return self.path_folder_gunicorn + "gunicorn.conf.py", res_gunicorn_conf_py,

	def TemplateNginxSitesEnabled(self):
		"""
		"""

		# include proxy_params !!!

		res = Template("""
server {
    # server_name {{ host }};

    listen 80;

    # Задаёт максимально допустимый размер тела запроса клиента.
    client_max_body_size 4G;

	location = /favicon.ico { access_log off; log_not_found off; }

    location /static/ {
            root {{ static }};
    }
    location /media/ {
            root {{ media }};
    }

    location / {
		        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		        proxy_set_header X-Forwarded-Proto $scheme;
		        proxy_set_header Host $http_host;
		        proxy_redirect off;
                proxy_pass http://{{ bind }};
    }
}
	    """).render(host=self.host,
		            static=self.path_proj,
		            media=self.path_proj,
		            bind=self.bind)

		return f"/etc/nginx/sites-enabled/{self.name_proj}_ngix", res

	@staticmethod
	def Input(text):
		if input(f"{text}: yes/n   ") == "yes":
			return True
		else:
			return False

	def InstallRequirements(self):
		if os.path.exists("requirements.txt"):
			system("pip install -r requirements.txt")
		elif os.path.exists("req.txt"):
			system("pip install -r req.txt")

	def ChangeALLOWED_HOSTS(self):
		with open(self.path_settings, 'r') as _file:
			file_read = _file.read()
			res = sub('ALLOWED_HOSTS\s*=\s*\[.+\]', f'ALLOWED_HOSTS = ["*"]', file_read)  # [800:900]
		with open(self.path_settings, "w") as _file:
			_file.write(res)

	@staticmethod
	def SearchMainAppDjango(search_file: str = "settings.py") -> Optional[str]:
		"""
		Поиск главного приложения
		"""
		for _path1 in listdir(path.dirname(__file__)):
			try:
				for _path2 in listdir(f"{path.dirname(__file__)}/{_path1}"):
					if _path2 == search_file:
						return _path1  # Файл, в котором лежит `setting.py` является главныйм
			except (NotADirectoryError, FileNotFoundError):
				pass
		raise FileNotFoundError(f"Файл `{search_file}` не найден")

	@staticmethod
	def save_file(file_name: str, text: str):
		with open(file_name, "w") as _file:
			_file.write(text)


if __name__ == '__main__':
	# Запустить скрипт
	DevOps().main()
```

# Контейнеры

[Официальный сайт Docker](https://hub.docker.com/)

## Установка

| ОС           | команда                                  |
| ------------ | ---------------------------------------- |
| `Arch Linux` | `sudo pacman -S docker docker-compose`   |
| `Ubuntu`     | `sudo apt install docker docker-compose` |
|              |                                          |

## `Makefile`

| ОС           | Команда                 |
| ------------ | ----------------------- |
| `Arch Linux` | `sudi pacman -S make`   |
| `Ubuntu`     | `sudo apt install make` |

---

`Makefile` нужны для хранения инструкций, дабы не писать каждый раз длинные команды в ручную их можно написать в `Makefile` и потом уже в одну команды вызвать[+](http://dkhramov.dp.ua/Comp.UsingMake#.YapOSiWOFis)

Правила оформления:

- `<команда>` Должна быть с отступом в один `TAB`
- Если нужно вызвать другую инструкцию пере выполнением команды, то напишите её после `:`
- Чтобы создать прерменную `<ИмяПеременной>=<Значение>`
- Чтобы прочитать переменную `$(<ИмяПеременной>)`

`Makefile`

```bash
<Инструкция1>:
[TAB]<команда1>

<Инструкция2>:
[TAB]<команда1>

<Инструкция3>: <Инструкция2>
[TAB]<команда1>


NameVar=value

<Инструкция4>:
[TAB]echo $(NameVar)
```

- Запросить ввод данных через консоль

    ```bash
    <ИмяИнструкции>:
    	@echo "What is your age?: "; \
    	read AGE; \
    	echo "Your age is ", $$(AGE)
    ```

- Передать именованные аргументы в инструкцию

    ```bash
    <ИмяИнструкции>:
    	echo $(args)
    ```

    Выполнить

    ```bash
    make <ИмяИнструкции> args=ЗначениеАргумента
    ```

- Предать позиционные аргументы в инструкцию

    ```bash
     <ИмяИнструкции>:
    	echo $(filter-out $@,$(MAKECMDGOALS)) > 1.txt
    ```

    Выполнить

    ```bash
    make <ИмяИнструкции> <ЗначениеАргумента1> <ЗначениеАргумента2> ...
    ```

- Конкатенация переменных

    ```bash
    a:="Hello"
    b:=$(a)_world
    ```

- Прочитать переменные окружения из файла

    ```bash
    env_path="ПутьК_Файлу"
    include $(env_path)
    export Ключ1, Ключ2, Ключ3
    ```

- Использовать переменную окружения или простую переменную

    ```bash
    $(ИмяПеременной)
    ```


- Выполнить инструкциию (нужно находится в одной папке с `Makefile`)

	```bash
	make <Инструкция1>
	```

---

```bash
# Путь к переменным окружения
env_path=__env.env
include $(env_path)
export EXTERNAL_WEB_PORT, WORK_DIR, NAME_PROJ

## Переменные
# Имя контейнера БД
db_container_name:=$(NAME_PROJ)-postgres-db_cont
# Имя контейнера `nginx`
nginx_container_name:=${NAME_PROJ}-nginx_cont
# Имя контейнера `WEB`
web_container_name:=$(NAME_PROJ)-djnago-web_cont
# Имя образа `WEB`
image_name:=$(NAME_PROJ)_img
# Текущую директория
my_path=$(shell dirname $(realpath $(firstword $(MAKEFILE_LIST))))
####


## Подготовить весь проект, Создать - Применить миграции
init_proj: dj_migrate
	npm install; 
####


## Docker
# Получить ip адрес указанного контейнера
docker_get_ip:
	docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(filter-out $@,$(MAKECMDGOALS));

# Получить ip адрес БД
docker_get_ip_db:
	docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(db_container_name);

# Получить ip адрес WEB приложения
docker_get_ip_web:
	docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $(web_container_name);

# Создать образ проекта(Нудно находиться на одном уровне с `Dockerfile`)
docker_build:
	docker build --build-arg WORK_DIR=$(WORK_DIR) --build-arg NAME_PROJ=$(NAME_PROJ) -t $(image_name) .;

# Создать и запустить контейнер с проектом
docker_run:
	docker run --rm -ti --name $(web_container_name) -v $(my_path)/deploy:$(WORK_DIR)/deploy -p $(EXTERNAL_WEB_PORT):$(EXTERNAL_WEB_PORT) $(image_name);

# Подключиться к контейнеру c web
docker_exec_web:
	docker exec -ti $(web_container_name) /bin/sh;

# Подключиться к контейнеру c web
docker_exec_db:
	docker exec -ti $(db_container_name) /bin/sh;

# Подключиться к контейнеру c nginx
docker_exec_nginx:
	docker exec -ti $(nginx_container_name) /bin/sh;

# Подключиться к указанному контейнеру
docker_exec:
	docker exec -ti $(filter-out $@,$(MAKECMDGOALS)) /bin/sh;
####


## Docker-compose
# Запустить образы контейнеров
docker_compose_build:
	sudo docker-compose --env-file $(env_path) build;

# Запустить контейнеры а после окончанию отчистить удалить их
docker_compose_up:
	sudo docker-compose --env-file $(env_path) up && sudo docker-compose --env-file $(env_path) rm -fsv;

# Удалить ненужные контейнеры
docker_compose_rm:
	sudo docker-compose --env-file $(env_path) rm -fsv;
####


## Django
# Запустить сервер `django`
dj_run:
	python $(NAME_PROJ)/manage.py runserver 0.0.0.0:$(EXTERNAL_WEB_PORT);

# Запустить сервер `gunicorn` с конфигурацией  `gunicorn.conf.py`
dj_gunicorn_run:
	gunicorn --chdir $(NAME_PROJ) --preload -c $(my_path)/deploy/gunicorn/gunicorn.conf.py;

# Запустить тестовый сервер `gunicorn`
dj_gunicorn_run_test:
	gunicorn --chdir $(NAME_PROJ) --preload -b 0.0.0.0:$(EXTERNAL_WEB_PORT) --reload conf.wsgi:application;

# Создать миграции в БД
dj_migrate:
	python $(NAME_PROJ)/manage.py makemigrations && python $(NAME_PROJ)/manage.py migrate

# Загрузить данные в БД из дампа (позиционный аргумент - имя фала с дампом)
dj_load:
	python $(NAME_PROJ)/manage.py migrate && python $(NAME_PROJ)/manage.py flush && python $(NAME_PROJ)/manage.py loaddata $(NAME_PROJ)/$(filter-out $@,$(MAKECMDGOALS));

# Создать дамб БД
dj_dump:
	python $(NAME_PROJ)/manage.py dumpdata > $(NAME_PROJ)/dump.json;

# Создать проект (позиционный аргумент - имя проекта)
dj_startproject:
	django-admin startproject $(filter-out $@,$(MAKECMDGOALS)); -e py,env,dockerignore,gitignore;
####


## React
# Запустить `webpack` (Для автамотической сборки проекта при изменнеи кода в `React`)
webpack_run:
	npm run dev
```

## `Docker`

Особенности:

- Образ = Сценарий установки. (Собирается из `Dockerfile`)
- Контейнер = Готовая виртуальная машина (Запускается)
- Все сценарии сборки и запуска контейнера хранятся в `Dockerfile`
- Если вы хотите исключить(проигнорировать) файл или папку в проекте при копирование, то укажите их в `.dockerignore`
- Чтобы пользователь `docker` выполнятся без `sudo` выполните следующие команды

    ```bash
    sudo usermod -aG docker $USER
    ```

%% `bash sudo groupadd docker; sudo gpasswd -a $USER docker; newgrp docker `%%

### Команды `docker`

| Команда                                                                                                                                                                                                                                                                 | Описание                                                                                           |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| --- Образы ---                                                                                                                                                                                                                                                          | ---                                                                                                |
| `sudo docker build [-t <ИмяДляНовогоОбраза>] [--build-arg <КлючАргумента>=<ЗначениеАргмента>] <ПутьК_ПапкеГдеХранитьсяDocerfile>`                                                                                                                                       | Собрать образ                                                                                      |
| `sudo docker images`                                                                                                                                                                                                                                                    | Посмотреть доступные(скаченные) образы                                                             |
| `sudo docker image rm <ImageId>`                                                                                                                                                                                                                                        | Удалить образ по указанному `IMAGE ID`                                                             |
| `sudo docker image prune`                                                                                                                                                                                                                                               | Удалить все неиспользуемые образы                                                                  |
| --- Контейнеры ---                                                                                                                                                                                                                                                      | ---                                                                                                |
| `sudo docker create [-ti] [--name <ЛюбовеНовоеИмяКонтейнера>] <ИмяОбраза>`                                                                                                                                                                                              | Создать контейнер из образа                                                                        |
| `sudo docker ps`                                                                                                                                                                                                                                                        | Посмотреть запущенные контейнеры                                                                   |
| `sudo docker ps -a`                                                                                                                                                                                                                                                     | Посмотреть историю запущенных контейнеров                                                          |
| `sudo docker container start <ИмяКонтейнера/Id>`                                                                                                                                                                                                                        | Запускает остановленные контейнеры                                                                 |
| `sudo docker container attach <ИмяКонтейнера/Id>`                                                                                                                                                                                                                       | Подключиться к выводу консоли контейнера                                                           |
| `sudo docker container stop <ИмяКонтейнера>`                                                                                                                                                                                                                            | Остановить контейнер                                                                               |
| `sudo docker container stop $(docker ps -a -q)`                                                                                                                                                                                                                         | Остановить все контейнеры                                                                          |
| `sudo docker container rm <ИмяКонтейнера>`                                                                                                                                                                                                                              | Удалить указанный контейнер                                                                        |
| `sudo docker container prune`                                                                                                                                                                                                                                           | Удалить все неиспользуемыем контейнеры                                                             |
| `sudo docker run [-ti] [--rm (удалить_контейнер по окончанию)] [-v РеальныйПутьК_Папке:ПутьВ_контенере (зеркальный папки)] [--env-file <ПутьК_Фалу_С_ПО>.env] [--name=<ИмяДляНовогоКонтейнера>] [-p <РеальныйПорт>:<ПортВ_Контейнере>] [-d (ФоновыйРежим)] <ИмяОбраза>` | Запустить контейнер на основе указанного образа. (Чтобы отключиться от контейнера `Ctrl+P Ctrl+Q`) |
| `sudo docker run [...теже_агрументы...] bash`                                                                                                                                                                                                                           | Запустить контейнер и войти в него                                                                 |
| --- Информация ---                                                                                                                                                                                                                                                      | ---                                                                                                |
| `sudo docker logs <ИмяКонтейнера>`                                                                                                                                                                                                                                      | Посмотреть логи контейнера                                                                         |
| `sudo docker volume ls`                                                                                                                                                                                                                                                 | Посмотреть все общие папки(файлы)                                                                  |
| ` docker history <ИмяОбраза>`                                                                                                                                                                                                                                           | Посмотерть размер слоев у образа                                                                   |
| --- Другое ---                                                                                                                                                                                                                                                          | ---                                                                                                |
| `sudo docker exec -it <ИмяКонтейнера/Id> bash`                                                                                                                                                                                                                          | Войти в контейнер                                                                                  |
| --- Импорт/Экспорт ---                                                                                                                                                                                                                                                  | ---                                                                                                |
| `sudo docker commit <ИмяКонтейнреа> <НовоеИмяИзображения>`                                                                                                                                                                                                              | Сохранить состояние контейнера в новый образ                                                       |
| `sudo docker save -o <ИмяАрхива>.tar <ИмяИзображения1> [<ИмяИзображения2>(можно_указать_несколько)]`                                                                                                                                                                    | Сохранить изображения в архив                                                                      |
| `sudo docker load -i <ИмяАрхива>.tar`                                                                                                                                                                                                                                   | Создать образ на основе архива (с образом)                                                         |
| `sudo docker export -o <ИмяАрхива>.tar <ИмяКонтейнера>`                                                                                                                                                                                                                 | Сохранить контейнер в архив                                                                        |
| `sudo docker import <ИмяАрхива>.tar <НовоеИмяОбраза>`                                                                                                                                                                                                                   | Создать образ на основе архива (с контейнером)                                                     |

---

- Удалить все ненужные образы и контейнеры

    ```bash
    sudo docker image prune;
    sudo docker container prune;
    ```

### Оформление `Dockerfile`

Хороший вариант структура проекта `django`

- `ИмяПроекта`
    - `Dockerfile` (Настройки сборки образа `web-django`)
    - `entrypoint.sh` (Скрипт исполняемы при запуске `WEB` контейнера)
    - `__env.env` (Файл с переменными окружения)
    - `gunicorn`
        - `gunicorn.conf.py` (Конфигурации для `gunicorn`)
        - `gunicorn_ass.log` (Файл с ифно логами)
        - `gunicorn_err.log` (Файл с ошибками)
    - `nginx`
        - `Dockerfile` (Настройки сборки образа `nginx`)
        - `default.conf.template` (Шаблон конфигурациий для `nginx`)
    - `manage.py`

---

`Dockerfile` По умолчанию `docker` ищет этот файл там где вы исполняете команду.

```python
# Взять за основу образ `python` `alpine` самый легковестный `Linux`
FROM python:3.9-alpine

# Получем аргумент из `docker-compose.yml` (путь рабочей деректории)
ARG WORK_DIR
# Отобразить путь к консоле дабы убедиться в существавание Аргумента
RUN echo $WORK_DIR
# Создать робочую деректроию проекта ( Обычно путь такой `/usr/src/<ИмяПрограммы>`)
WORKDIR $WORK_DIR


ENV \
    # Не создавать папку `.pyc` для кеширование байт кода
    PYTHONDONTWRITEBYTECODE=1 \
    # Не кешировать вывод из консоли
    PYTHONUNBUFFERED=1


COPY \
    # Скопировать файл зависемсотие в рабочую деректроию
    requirements.txt    \
    # Разрешить исполнять скрипты
    entrypoint.sh       \
    # Скопировать весь проект в робочию дерикторию
    .                   \
    # Путь для копирывания
    ./

RUN \
    # Обновить `pip`
    pip install --upgrade pip;\
    # Установить зависемости из файла
    pip install -r requirements.txt; \
    # Разрешить исполнять файл
    chmod +x entrypoint.sh; \
	# Отчистить кеш `apt`
	rm -rf /var/lib/apt/lists/*;


# Выполнить скрипт при запуске контейнера
ENTRYPOINT sh ${WORK_DIR}/entrypoint.sh
```

[Большая документация про `Dockerfile`](https://dker.ru/docs/docker-engine/engine-reference/dockerfile-reference/)

| Ключ                                                    | Описание                                                                                                                                                               |
| ------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| FROM `<ИмяОбраза>:<Тег/Версия>`                         | Задает базовый образ                                                                                                                                                   |
| ---                                                     | ---                                                                                                                                                                    |
| ARG `<ИмяАргумента>`                                    | Получает аргумент из команды сборки (`--build-arg`-команда)(`args:`-`docker-compose.yml`)(используется для получения ПО из `docker-compose.yml`)                       |
| ENV `<ИмяПО> <ЗначениеПО>`                              | Создать переменную окружения                                                                                                                                           |
| ---                                                     | ---                                                                                                                                                                    |
| WORKDIR `<ПутьК_Дериктории>`                            | Задать путь к для хранения рабочей директории и перейти в неё. (по этому пути будет храниться проект в контейнере)(точка `.` будет равна указанному пути в `WORKDIR` ) |
| ---                                                     | ---                                                                                                                                                                    |
| COPY `<ОткудаЧтоКопировать> <Куда>`                     | Копировать файл или папку. (Напишите `.` точку, для того чтобы использовать относительный путь от `Docerfile` )                                                        |
| ADD `<Url> <Куда>`                                      | Скачать указанный файл, и поместить его в указанный путь.                                                                                                              |
| ---                                                     | ---                                                                                                                                                                    |
| RUN `<Команда>`                                         | Выполнить команду. Используется для установки в контейнер пакетов. (Выполняется один раз при сборки)                                                                   |
| CMD `['<Команда>', '<Аругмент11>', '<Аргумент2>', ...]` | Выполнить команду когда контейнер будет запущен. (Выполняется каждый раз при запуске)                                                                                  |
| ENTRYPOINT `["sh", "ПутьКСкриптуВ_Контейнере"]`         | Выполнить указанный скрипт при запуске контейнера.(Обязательно разрешить выполнять указанный скрипт `RUN chmod +x entrypoint.sh`)                                      |
| ---                                                     | ---                                                                                                                                                                    |
| EXPOSE `<НомерПорта>`                                   | Открыть указанный порт. (Будет открыть если запустить контейнер командой `docker run -P`)                                                                              |
| VOLUME `<ПутьК_ЗеркальнойПапке>`                        | Связать реальную папку с папкой в контейнере.                                                                                                                          |
| ---                                                     | ---                                                                                                                                                                    |
| `${Ключ}`                                               | Вставить значение из переменной или аргумента                                                                                                                          |

---

`entrypoint.sh` файл со скриптами, которые будут выполняться при старте контейнера.

```bash
#! /bin/bash

# Получить данные из файла с переменными окружения
export $(grep -v '^#' ./__env.env | xargs)

# Создать миграции
python ${NAME_PROJ}/manage.py makemigrations --no-input
# Применить миграции
python ${NAME_PROJ}/manage.py migrate --no-input

# Запустить сервер django
#python ${NAME_PROJ}/manage.py runserver 0.0.0.0:${EXTERNAL_WEB_PORT}

## Запустить сервер gunicorn
gunicorn --chdir ${NAME_PROJ} -c $(pwd)/deploy/gunicorn/gunicorn.conf.py
```

[Шаблон для `gunicorn`](#Шаблон%20для%20docker)

### Подключение к контейнерам

- Войти в любой контейнер

    ```bash
      docker exec -it <ИмяКонтейнера/Id> bash
    ```

    или

    ```bash
      docker exec -it <ИмяКонтейнера/Id> sh
    ```

    или

    ```bash
      docker exec -it <ИмяКонтейнера/Id> /bin/sh
    ```

- Подключиться к БД которая находится в контейнере. (Нужна указать именно `ip` адрес, а не имя контейнера в `Host:`) Для того чтобы узнать `IP` адрес контейнера используйте команду

    ```bash
    docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <CONTAINER_ID/NAMES>
    ```

    ![Подключиться к БД которая находится в контейнере](_attachments/a99c5ec12ed9fab9772ca82f0080e6f6.png)

### Как обмениваться контейнерами и изображениями `docker`

Источники:

- [Основной](https://netpoint-dc.com/blog/sohranenie-i-zagruzka-obrazov-kontejnerov-docker/)
- [Запосной](https://dev-gang.ru/article/kak-perenesti--peremestit-obraz-docker-v-druguu-sistemu-4fo9wdw42y/)

---

Для того чтобы распространять вашу программу в `Docker` обычно архивируют образ программы, а сам контейнер должен создаваться уже на месте.

- Сохранить одно или несколько изображений. (Контейнер должен быть запущен !) (Принято хранить в `.tar` архиве)

    ```bash
    sudo docker save -o <ИмяАрхива>.tar <ИмяИзображения1> [<ИмяИзображения2>(можно_указать_несколько)]
    ```

> Можно зафиксировать изменения в контейнере в новый образ. А потом уже сохранить его в архив
>
> ```bash
> sudo docker commit <ИмяКонтейнреа> <НовоеИмяИзображения>
> ```

- Прочитать архив с изображением

    ```bash
    sudo docker load -i <ИмяАрхива>.tar
    ```

---

Если нужно скопировать весь контейнер со всеми данными в нутри то нужно использовать.

- Создать Бекап(Сохранение) всей файловой системы контейнера.

    ```bash
    sudo docker export -o <ИмяАрхива>.tar <ИмяКонтейнера>
    ```

- Создать новый образ на основе архива с бекапом

    ```bash
    sudo docker import <ИмяАрхива>.tar <НовоеИмяОбраза>
    ```

---

## `Docker-compose`

Все сценарии запуска нескольких(или одного) контейнеров хранятся в `docker-compose.yml`(Он нужен для управления запуска контейнеров)

---

Для удобного редактирования файлов `docker-compose.yml` используйте. `Vs Code` и плагы

- [`YAML`](https://open-vsx.org/vscode/item?itemName=redhat.vscode-yaml)
- [`Docker`](https://open-vsx.org/vscode/item?itemName=ms-azuretools.vscode-docker)

---

### Команды `docker-compose`

| Команда                                                                                                            | Описание                                                                                                     |
| ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |
| `sudo docker-compose [--env-file <ПутьК_Фалу_С_ПО>.env] config`                                                    | Вывести конфигурации файла `docker-compose.yaml` с учетом вставки переменных окружения                       |
| ---                                                                                                                | ----                                                                                                         |
| `sudo docker-compose [--env-file <ПутьК_Фалу_С_ПО>.env] build `                                                    | Собрать образ указанный в `docker-compose.yaml` (нужно находится в одной папке с файлом)                     |
| `sudo docker-compose [--env-file <ПутьК_Фалу_С_ПО>.env] [--no-build (пропустить_сборку_и_использовать_образы)] up` | Запустить контейнеры по указанному сценарию в `docker-compose.yaml` (нужно находится в одной папке с файлом) |
| `sudo docker-compose dowm`                                                                                         | Остановить контейнеры                                                                                        |
| `sudo docker-compose up && sudo docker-compose rm -fsv`                                                            | Запустить контейнер, и удалить их при остоновке.                                                             |
| ---                                                                                                                | ---                                                                                                          |
| `sudo docker-compose logs <ИмяСервиса>`                                                                            | Посмотреть логи у указанного сервиса                                                                         |
| `sudo docker-compose exec <ИмяСервиса> <КомандаВ_Контейне>`                                                        | Выполнить указанную команду в указанном сервисе                                                              |
| `sudo docker-compose exec <ИмяСервиса> bash`                                                                       | Войти в сервис                                                                                               |
| ---                                                                                                                | ---                                                                                                          |
| `sudo docker-compose ps`                                                                                           | Посмотреть все запущенные контейнеры                                                                         |
| `sudo docker-compose images`                                                                                       | Посмотреть все образы                                                                                        |

### Оформление `docker-compose.yml`

Приме оформления `docker-compose.yml`. Здесь два сервиса(контейнера) один это БД другой это `WEB` приложение.

```yml
# Версия docker-compose
version: "3"

# Список контейнеров(сервисов)
services:

  # Контейнер с базой данных
  db:
    # Имя контейнера
    container_name: "${NAME_PROJ}-postgres-db_cont"

    # Перезапускать контейнер если он упал
    restart: always

    # Взять готовый образ `postgres`
    image: "postgres:alpine"

    # Зеркальная папка с БД
    # Если вы хотите использовать данные из реальной БД(которая вне контейнера)
    # То установите путь `./data/db:/var/lib/postgresql/data`
    volumes:
      - "${POSTGRES_VOLUMES}:/var/lib/postgresql/data"

    # Взять переменные окружения
    env_file: ${PATH_ENV}

  # Даем любое название для WEB контейнера
  web:

    # Имя контейнера
    container_name: "${NAME_PROJ}-djnago-web_cont"

    # Найти Dockerfile(по указанному пути) и собрать контейнер
    build:
      context: .
      # Передать аргумент с путем к рабочей деректории
      args:
        WORK_DIR: ${WORK_DIR}
        NAME_PROJ: ${NAME_PROJ}

    # Путь к файлу с переменными окружениями  (Эти переменные будут доступны во всем контейнере)
    env_file: ${PATH_ENV}

    # Зеркальная папка с Проектом
    volumes:
      # - ".:${WORK_DIR}"
      - "./deploy:${WORK_DIR}/deploy"

    # Проброска портов для web приложения `<РеальныйПорт>:<ПортВ_Контейнере>`
    ports:
      - ${EXTERNAL_WEB_PORT}:${EXTERNAL_WEB_PORT}

    # Зависит от контейнеров(сервисов)
    depends_on:
      - db

  # Контейнер `Nginx`
  ngix:
    # Имя контейнера
    container_name: "${NAME_PROJ}-nginx_cont"

    # Путь для сбора образа
    build: ./deploy/nginx

    # Проброска портов
    ports:
      - ${NGINX_PORT}:${NGINX_PORT}

    # Путь к файлу с переменными окружениями  (Эти переменные будут доступны во всем контейнере)
    env_file: ${PATH_ENV}

    # Зависит от `web` приложения
    depends_on:
      - web
```

[Большая документация про `docker-compose.yaml`](https://dker.ru/docs/docker-compose/compose-file-reference/)

| Ключ:тип:подтип                                   | Описние                                                                                                                                                                                                                                                   |
| ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| version: `str`                                    | Версия `docker-compose`                                                                                                                                                                                                                                   |
| container_name: `str`                             | Имя контейнера                                                                                                                                                                                                                                            |
| ---                                               | ---                                                                                                                                                                                                                                                       |
| services: `dict`                                  | Список со всеми сервисами(контейнеров)                                                                                                                                                                                                                    |
| depends_on: `list`: `str`                         | Зависимости с другими контейнерами. Сначала запускаются зависимости потом главный контейнер                                                                                                                                                               |
| restart: always                                   | Повторно загружать контейнер если он завершил работу                                                                                                                                                                                                      |
| ---                                               | ---                                                                                                                                                                                                                                                       |
| image: `str`                                      | Задает образ. (аналог `FROM` из `Dockerfile`) (Если указать несуществующий образ, то тогда созданный образ будет иметь иметь это ! )                                                                                                                      |
| build: `dict`                                     | Путь к `Dockerfile`. Принимает также `args: dict` в котром можно указать аргументы доступные в `Dockerfile`                                                                                                                                               |
| ---                                               | ---                                                                                                                                                                                                                                                       |
| ports: `list`:`<РеальныйПорт>:<ПортВ_Контейнере>` | Проброс портов меду реальной машиной и контейнером.                                                                                                                                                                                                       |
| expose: `lsit`:`str`                              | Список портов которые прослушивает(обрабатывает) непосредственно контейнер (это просто подсказка).                                                                                                                                                        |
| network_mode: host                                | Сделать общую сеть между реальной машиной и контейнером (Стоит использовать если вы хотите подключиться из контейнера к локальной сети реальной машины)                                                                                                   |
| ---                                               | ---                                                                                                                                                                                                                                                       |
| env_file: `str` или список с путями               | Путь к файлу с переменными окружениями                                                                                                                                                                                                                    |
| environment: `dict` : `str`                       | Указать переменные окружения прямо в файле `docker-compose.yml`                                                                                                                                                                                           |
| volumes: `list`:`str`                             | Связать реальную папку с контейнером. (Все изменения в реальной папке будут отражены в контейнере, и все изменения в контейнере будут отражены в реальной папке. Похоже на зеркало) (Если указать в конце пути `:ro` это означает файл только для чтения) |
| working_dir: `str`                                | Путь к рабочей директории внутри контейнера                                                                                                                                                                                                               |
| ---                                               | ---                                                                                                                                                                                                                                                       |
| command: `str`                                    | Выполнить указанную команду при запуски контейнреа                                                                                                                                                                                                        |
| ---                                               | ---                                                                                                                                                                                                                                                       | 
| `${Ключ}`                                         | Вставить значение из переменной или аргумента                                                                                                                                                                                                             |

---

Использование переменных окружений в файле `docker-compose.yml`[+](https://docs.docker.com/compose/environment-variables/).

- По умолчанию `docker-compose` ищет файл `.env`(именно такой файл) с переменными окружения в той же директории где `docker-compose.yml`. Для того чтобы указать другое имя файла с переменными окружениями укажите флаг `--env-file <ПутьК_Фалу_С_ПО>.env` к команде `docker-compose`.
- Переменны окружения, которые добавлены через `env_file: ...` также доступны для использования в `docker-compose.yml`

- Использование переменных окружений в файле `docker-compose.yml`

    ```yml
    ${ИмяПерееннойОкружения}
    ```

`__env.env` Файл с переменными окружениями. Оформлять в виде (`<ключ>=<занчение>`)

```bash
# (!) - обозначает что нельзя изменять имя ПО, так как его используют официальное образы.

## Django
# Ключ для расшифровки сессии
DJANGO_SECRET_KEY="{{ secret_key }}"
# Имя проекта
NAME_PROJ="{{ project_name }}"


### Docker
# Путь к рабочей директории
WORK_DIR="/usr/src/{{ project_name }}"
# Путь к переемным окружениям
PATH_ENV="./__env.env"
# Внешний порт <!Изменить значеня на свои>
EXTERNAL_WEB_PORT=8081
# Внешний и Внутрений порт для `nginx`. EXTERNAL_WEB_PORT != NGINX_PORT <!Изменить значеня на свои>
NGINX_PORT=8080


### Postgres
#  Имя БД (!) <!Изменить значеня на свои>
POSTGRES_DB="postgres"
# Имя пользователя (!) <!Изменить значеня на свои>
POSTGRES_USER="postgres"
# Пароль от пользователя (!) <!Изменить значеня на свои>
POSTGRES_PASSWORD="postgres"
# Имя сервиса(контейнера)
POSTGRES_HOST="db"
# Порт подключения к БД. (По умолчанию 5432)
POSTGRES_PORT=5432
# Путь к зеркальной папке с БД
POSTGRES_VOLUMES="./db/pg_data"
```

`settings.py` Шаблон подключения к `PostgreSQL`

```python
DATABASES = {
		'default': {

				'ENGINE'  : 'django.db.backends.postgresql_psycopg2',  # Адаптер
				'NAME'    : os.environ.get('POSTGRES_DB', default=''),  # Имя Бд
				'USER'    : os.environ.get('POSTGRES_USER', default=''),  # Имя пользователя
				'PASSWORD': os.environ.get('POSTGRES_PASSWORD', default=''),  # Пароль от пользователя
				'HOST'    : os.environ.get('POSTGRES_HOST', default='localhost'),  # Хост, имя контейнера.
				'PORT'    : os.environ.get('POSTGRES_PORT', default=5432),  # Порт для подключения к БД.
		},
}
```

### Сборки `docker-compose.yml`

Если вы используете реальную локальную базу данных. Для контейнера с `WEB` приложением.

- Создаем контейнер только с `web` приложением
- Используем общую сеть между контейнером и реальной машиной

```yaml
# Версия docker-compose
version: "3"

# Список контейнеров
services:

  # Даем любое название для WEB контейнера
  name_web:

	# Найти Dockerfile(по указанному пути) и собрать контейнер
	build:
	  context: .
	  # Передать аргумент с путем к рабочей деректории
	  args:
		WORK_DIR: ${WORK_DIR}

	# Путь к файлу с переменными окружениями  (Эти переменные будут доступны во всем контейнере)
	env_file: ${PATH_ENV}


	# Зеркальная папка с Проектом
	volumes:
	  - ".:${WORK_DIR}"

	# Так как сеть общая то проброска портов будет проигнорирована
	# ports:
	#  - ${EXTERNAL_WEB_PORT}:8000

	# Имя контейнера
	container_name: "djnago-web"

	# Не вертуализировать сеть а использовать реальную сеть !!!
	network_mode: host

```

---

Если вы используете локальный контейнер с БД. Который используется для контейнера с `WEB` приложением.

- Создаем контейнеры с `web` приложением и бд `db`

```yml
# Версия docker-compose
version: "3"

# Список контейнеров
services:

  # Контейнер с базой данных
  db:
    # Взять готовый образ `postgres`
    image: "postgres"

    # Зеркальная папка с БД
    # Если вы хотите использовать данные из реальной БД(которая вне контейнера)
    # То установите путь
    volumes:
      - "${POSTGRES_VOLUMES}:/var/lib/postgresql/data"

    # Имя контейнера
    container_name: "postgres-db"

	# Перезапускать контейнер если он упал
	restart: always

    # Взять переменные окружения
    env_file: ${PATH_ENV}

  # Даем любое название для WEB контейнера
  name_web:

    # Найти Dockerfile(по указанному пути) и собрать контейнер
    build:
      context: .
      # Передать аргумент с путем к рабочей деректории
      args:
        WORK_DIR: ${WORK_DIR}

    # Путь к файлу с переменными окружениями  (Эти переменные будут доступны во всем контейнере)
    env_file: ${PATH_ENV}

    # Зеркальная папка с Проектом
    volumes:
      - ".:${WORK_DIR}"

    # Проброска портов для web приложения `<РеальныйПорт>:<ПортВ_Контейнере>`
    ports:
      - ${EXTERNAL_WEB_PORT}:8000

    # Имя контейнера
    container_name: "djnago-web"

    # Зависит от контейнеров(сервисов)
    depends_on:
      - db

```

---

Контейнер `Nginx` `WEB` `PostgreSQL`

> `Ngix` - По умолчанию в конфигурациях `nginx` нельзя использовать переменные окружения. Но в `docker` есть специальная возможность это сделать. Для этого нужно в контейнере в папке `/etc/nginx/templates/*.template` шаблоны с расширением `.template`, при запуске контейнера `docker` возьмет шаблон и сгенерирует результат в папку `/etc/nginx/conf.d/`(с таким же имением как и шаблон только без расширения `.template`)

- `ВашПроект`

    - `__env.env`

        ```bash
        # (!) - обозначает что нелья изменять имя ПО, так как его используют офицальное образы.
        # Docekr

        # Путь к рабочей деректори
        WORK_DIR=/usr/src/<!>

        # Путь к зеракльной папке с БД
        POSTGRES_VOLUMES=./pg_datae
        # Путь к переемнным окружениям
        PATH_ENV=./__env.env
        # Имя проекта
        NAME_PROJ=<!>
        # Внешний порт
        EXTERNAL_WEB_PORT=8081
        # Общий порт для `nginx`
        NGINX_PORT=8080


        # Postgres

        #  Имя БД (!)
        POSTGRES_DB=<!>
        # Имя пользователя (!)
        POSTGRES_USER=<!>
        # Пароль от пользователя (!)
        POSTGRES_PASSWORD=<!>
        # Имя сервиса(контейнера)
        POSTGRES_HOST=db
        # Порт подключения к БД. (По умолчанию 5432)
        POSTGRES_PORT=5432
        ```

    - `Dockerfile` (Мы используем этот файл для `docer-compose`)

        ```yaml
        # Версия docker-compose
        version: "3"

        # Список контейнеров
        services:

        	  # Контейнер с базой данных
        	  db:
        		  # Имя контейнера
        		  container_name: "postgres-db"

        		  # Взять готовый образ `postgres`
        		  image: "postgres"

        		  # Перезапускать контейнер если он упал
        		  restart: always

        		  # Зеркальная папка с БД
        		  # Если вы хотите использовать данные из реальной БД(которая вне контейнера)
        		  # То установите путь
        		  volumes:
        			- "${POSTGRES_VOLUMES}:/var/lib/postgresql/data"

        		  # Взять переменные окружения
        		  env_file: ${PATH_ENV}

        	  # WEB контейнер
        	  name_web:
        		  # Имя контейнера
        		  container_name: "djnago-web"

        		  # Найти Dockerfile(по указанному пути) и собрать контейнер
        		  build:
        			# Путь к `Dockerfile`
        			context: .
        			# Передать аргумент в `Dockerfile` с путем к рабочей деректории
        			args:
        			  WORK_DIR: ${WORK_DIR}

        		  # Путь к файлу с переменными окружениями  (Эти переменные будут доступны во всем контейнере)
        		  env_file: ${PATH_ENV}

        		  # Зеркальная папка с Проектом
        		  volumes:
        			- ".:${WORK_DIR}"

        		  # # Не будем пробрасывать порты между реальной машиной и контейнером
        		  # ports:
        		  #   - "${EXTERNAL_WEB_PORT}:8009"

        		  # Разрешим контейнеру обробатывать запрос с указанного порта. Это нужно для переадресацци
        		  # (проксирования) с `nginx` контейнера в `web` контейнер
        		  expose:
        			- ${EXTERNAL_WEB_PORT}

        		  # Зависит от БД
        		  depends_on:
        			- db

        	  # Контейнер `Nginx`
        	  name_ngix:
        		  # Имя контейнера
        		  container_name: "nginx-web"

        		  # Путь для сбора образа
        		  build: ./nginx

        		  # Проброска портов
        		  ports:
        			- ${NGINX_PORT}:${NGINX_PORT}

        		  # Путь к файлу с переменными окружениями  (Эти переменные будут доступны во всем контейнере)
        		  env_file: ${PATH_ENV}

        		  # Зависит от `web` приложения
        		  depends_on:
        			- name_web
        ```

    - `nginx`

        - `default.conf.template` (Шаблон для `nginx`)

            ```conf
            server {
            	listen ${NGINX_PORT} default_server;

            	# Задаёт максимально допустимый размер тела запроса клиента.
            	client_max_body_size 4G;

            	location = /favicon.ico { access_log off; log_not_found off; }


            	#location /static/ {
            	#        root /home/denis/PycharmProjects/testvpn/experement;
            	#}
            	#location /media/ {
            	#        root /home/denis/PycharmProjects/testvpn/experement;
            	#}

            	location / {
            		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            		proxy_set_header X-Forwarded-Proto $scheme;
            		proxy_set_header Host $http_host;
            		proxy_redirect off;
            		proxy_pass http://name_web:${EXTERNAL_WEB_PORT};
            	}
            }
            ```

        - `Dockerfile`
            ```yaml
            # Беерм образ `nginx`
            FROM nginx
            # Удяляем стандарный конфиг
            RUN rm /etc/nginx/conf.d/default.conf
            # Копируем шаблон в контейнер
            COPY default.conf.template /etc/nginx/templates/default.conf.template
            ```

## `Kubernetes`

# `Heroku` - бесплатный хостинг для теста

- [`heroku`](https://www.heroku.com/python)
- [Шпаргалка для диплоя `Django`](https://realpython.com/django-hosting-on-heroku/)

Подготовка:

1. Регистрация [+](https://signup.heroku.com/)
2. Скачать программу для `heroku` [+](https://devcenter.heroku.com/articles/heroku-cli)
   Linux
    ```bash
     sudo snap install --classic heroku;
    ```
3. `heroku login` зарегистрироваться

---

Диплой:

1. Войти в папку с проектом и создать приложение `heroku`

    ```bash
    heroku create <ИмяСайта>
    ```

    - Посмотреть список всех приложений

        ```bash
        heroku apps
        ```

    - Удалить приложение (Потом ввести еще раз имя приложения)

        ```bash
        heroku apps:destroy <ИмяПриложения>
        ```

1. Создать файл `Procfile`

    ```bash
    web: gunicorn [--chdir ПутьК_Проету (Изменить путь к проекту если это необходимо)] <ИмяПрограммы>.wsgi:application --log-file -
    ```

1. Создать файл `runtime.txt`

    ```bash
    python-3.9
    ```

1. Установите `WEB` сервер

    ```bash
    pip install Django gunicorn whitenoise;
    pip freeze -> requirements.txt;
    ```

1. Проверти в `Name_proj->settings.py->`

    ```python
    ALLOWED_HOSTS = ['*']
    STATIC_ROOT = os.path.join(BASE_DIR, 'static')
    ```

1. Зафиксируйте изменения в проекте и отправите их на `heroku`

    ```python
    git add -A;
    git commit -m "Имя Коммита";
    git push heroku main #  или `master`;
    ```

---
