# Основные структуры данных

## Теория:

### Бинарные деревья

![](_attachments/31d5bd81dc7b2d9dc40427218fd8fa48.png)

Реализация на [C++](https://github.com/denisxab/Data-structure-/blob/master/Binary_tree_1.cpp)

```python
from typing import Optional


class NodeBinaryTree:
	def __init__(self, val):
		self.left = None
		self.right = None
		self._key = val

	def __repr__(self):
		return str(self._key)


class BinaryTree:
	def __init__(self):
		self.root: Optional[NodeBinaryTree] = None
		self.size: int = 0

	def add(self, val):
		if self.root is None:
			self.root = NodeBinaryTree(val)
		else:
			self.__add(val, self.root)
		self.size += 1

	def __add(self, val, node):
		if val < node._key:
			if node.left is not None:
				self.__add(val, node.left)
			else:
				node.left = NodeBinaryTree(val)
		else:
			if node.right is not None:
				self.__add(val, node.right)
			else:
				node.right = NodeBinaryTree(val)

	def find(self, val):
		if self.root is not None:
			return self.__find(val, self.root)
		else:
			return None

	def __find(self, val, node):
		if val == node._key:
			return node._key
		elif val < node._key and node.left is not None:
			return self.__find(val, node.left)
		elif val > node._key and node.right is not None:
			return self.__find(val, node.right)

	def deleteTree(self):
		if self.root is not None:
			self.__deleteTree(self.root)
		self.root = None

	def __deleteTree(self, node=None):
		if node is not None:
			self.__deleteTree(node.left)
			self.__deleteTree(node.right)
			del node

	def printTree(self):
		if self.root is not None:
			self.__printTree(self.root)

	def __printTree(self, node):
		if node is not None:
			self.__printTree(node.left)
			print(f"{node._key}")
			self.__printTree(node.right)

	def remove(self, key):

		tmp: NodeBinaryTree = self.root
		del_: NodeBinaryTree = tmp
		save_val = key

		# Если это центр
		if key == self.root._key:
			# //Если  с ЛЕВО не пусто
			if del_.left is not None:
				# //Если с ПРАВО не пусто
				if del_.right is not None:
					self.root = del_.right
					tmp = self.root.left

					if tmp:
						# //Спуск до самого меньшего значения слева
						while tmp.left is not None:
							tmp = tmp.left
						tmp.left = del_.left
					else:
						self.root.left = del_.left

				# //Если с ПРАВО пусто
				elif del_.right is None:
					self.root = self.root.left

			# //Если с ЛЕВО пусто
			elif del_.left == None:
				self.root = self.root.right

			save_val = del_._key
			del del_._key
			del del_
			self.size -= 1
			return save_val

		while True:
			# //Удаление и преставление элементов дерева

			# //Если с ЛЕВА
			if tmp.left != None and key == tmp.left._key:
				del_ = tmp.left
				# //Если  с ЛЕВО не пусто
				if del_.left != None:
					# //Если с ПРАВО не пусто
					if del_.right != None:
						tmp.left = del_.right
						tmp = tmp.left
						# //Спуск до самого меньшего значения слево
						while (tmp.left != None):
							tmp = tmp.left
						tmp.left = del_.left
					# //Если с ПРАВО пусто
					elif del_.right == None:
						tmp.left = del_.left

				# //Если с ЛЕВО пусто
				elif del_.left == None:
					tmp.left = del_.right

				save_val = del_._key
				del del_._key
				del del_
				self.size -= 1
				return save_val

			# //Если с ПРАВА
			elif tmp.right != None and key == tmp.right._key:
				del_ = tmp.right
				# //Если  с ЛЕВО не пусто
				if del_.left != None:
					# //Если с ПРАВО не пусто
					if del_.right != None:
						tmp.right = del_.right
						tmp = tmp.right
						# //Спуск до самого меньшего значения слево
						while (tmp.left != None):
							tmp = tmp.left
						tmp.left = del_.left
					# //Если с ПРАВО пусто
					elif del_.right == None:
						tmp.right = del_.left

				# //Если с ЛЕВО пусто
				elif del_.left == None:
					tmp.right = del_.right

				save_val = del_._key
				del del_._key
				del del_
				self.size -= 1
				return save_val

			# //Передвижение по дереву

			# //Если с ЛЕВА
			if key < tmp._key:
				if tmp.left != None:
					tmp = tmp.left
				elif tmp.left == None:
					raise ValueError("Ключ не найден")
			elif key > tmp._key:
				if tmp.right != None:
					tmp = tmp.right
				elif tmp.right == None:
					raise ValueError("Ключ не найден")


if __name__ == '__main__':
	#     3
	# 0     4
	#   2      8
	tree = BinaryTree()
	tree.add(3)
	tree.add(4)
	tree.add(0)
	tree.add(8)
	tree.add(2)

	# tree.remove()

	tree.printTree()
	print()
	print(tree.find(3))
	print(tree.find(110))
	tree.deleteTree()
	tree.printTree()
```

---

> Придумали в 1960 году

Сложность алгоритма

Память O(N)
Поиск O(log N)
Вставка O(log N)
Удаление O(log N)

---

### Хеш таблицы

```python
from typing import NamedTuple


class Colisuion(NamedTuple):
	arr: list


class HashMap:

	def __init__(self, start_size: int=0):
		self.__arr = [None for _x in range(start_size)]
		self.size = start_size

	def __get_index(self, key: int):
		return hash(key) % self.size

	def add(self, key):
		_index: int = self.__get_index(key)

		if self.__arr[_index] is None:
			self.__arr[_index] = key
		elif type(self.__arr[_index]) == Colisuion:
			self.__arr[_index].arr.append(key)
		else:
			self.__arr[_index] = Colisuion(arr=[key])

	def find(self, key):
		_index: int = self.__get_index(key)

		if self.__arr[_index] is None:
			return False

		elif type(self.__arr[_index]) == Colisuion:

			if key in self.__arr[_index].arr:
				return True
			else:
				return False
		else:
			return False

	def remove(self, key):
		_index: int = self.__get_index(key)

		if self.__arr[_index] is None:
			raise KeyError

		elif type(self.__arr[_index]) == Colisuion:
			self.__arr[_index].arr.remove(key)

		else:
			self.__arr[_index] = None

	def __repr__(self):
		return f"{self.__arr}"


if __name__ == '__main__':
	dict_ = HashMap(10)

	for _x in range(30):
		dict_.add(_x)

	print(dict_)
	print(dict_.find(22))
	print(dict_.find(222))
	dict_.remove(22)
	print(dict_.find(22))
```

---

> Придумали в 1953 году

Сложность алгоритма

Память O(N)
Поиск O(1)
Вставка O(N)
Удаление O(N)

---

### Стек

![](_attachments/a795dc3312adbd6b13b2416f46bbe637.png)

```python
class Stack:

	def __init__(self) -> None:
		self.__arr = []

	def append(self, var):
		self.__arr.append(var)

	def get(self):
		return self.__arr.pop()

	def __repr__(self):
		return f"{self.__arr}"


if __name__ == '__main__':
	stack = Stack()

	for _x in range(10):
		stack.append(_x)

	print(stack)
	print(stack.get())
	print(stack.get())
	print(stack.get())
	print(stack.get())
	print(stack.get())
	print(stack)
```

### Очередь

![](_attachments/32438c9381f237be2a8526120807672b.png)

```python
from collections import deque


class Deque:

	def __init__(self) -> None:
		self.__arr = deque()

	def append(self, var):
		self.__arr.append(var)

	def get(self):
		return self.__arr.popleft()

	def __repr__(self):
		return f"{self.__arr}"


if __name__ == '__main__':
	stack = Deque()

	for _x in range(10):
		stack.append(_x)

	print(stack)
	print(stack.get())
	print(stack.get())
	print(stack.get())
	print(stack.get())
	print(stack.get())
	print(stack)
```

### Графы

![](_attachments/8d819997ea75889403d531dbabc254d8.png)

```python
from collections import deque


def dfs(visited, graph, node):
	print(node, end=" ")

	if node in visited:  # Если вершина уже посещена, выходим
		return False

	visited.add(node)  # Посетили вершину v

	for _i in graph[node]:  # Все смежные с v вершины
		if not _i in visited:
			dfs(visited, graph, _i)


if __name__ == '__main__':
	graph = {
			1: [2, 8],
			2: [1, 3, 8],
			3: [2, 4, 8],
			4: [3, 7, 9],
			5: [6, 7],
			6: [5],
			7: [4, 5, 8],
			8: [1, 2, 3, 7],
			9: [4],
			}

	start = 1
	visited = set()
	dfs(visited, graph, start)
	print()
```

---

![](_attachments/ede70dcd294091e817b30ef08581dd23.png)

```python
from collections import deque


def bfs(visited, graph, node, queue):
	visited.append(node)
	queue.append(node)
	while queue:
		s = queue.popleft()
		print(s, end=" ")
		for neighbour in graph[s]:
			if neighbour not in visited:
				visited.append(neighbour)
				queue.append(neighbour)


if __name__ == '__main__':
	graph = {
			1: [2, 8],
			2: [1, 3, 8],
			3: [2, 4, 8],
			4: [3, 7, 9],
			5: [6, 7],
			6: [5],
			7: [4, 5, 8],
			8: [1, 2, 3, 7],
			9: [4],
			}

	start = 1

	visited = []
	Q = deque()  # Очередь
	bfs(visited, graph, start, Q)
```

## Закрепеление:

### !

==Задание== Спроектировать, класс для структуры данных двусвязный список.

# Сортировки

## Теория:

### Пузырьковая сортировка

```python
def bubble_sort(nums):
	# Устанавливаем swapped в True, чтобы цикл запустился хотя бы один раз
	len_ = len(nums) - 1

	swapped = True
	while swapped:

		swapped = False
		for i in range(len_):

			print(nums)

			if nums[i] > nums[i + 1]:
				# Меняем элементы
				nums[i], nums[i + 1] = nums[i + 1], nums[i]
				# Устанавливаем swapped в True для следующей итерации
				swapped = True

		print("_" * 40)


if __name__ == '__main__':
	random_list_of_nums = [5, 2, 1, 8, 4]
	bubble_sort(random_list_of_nums)
	print(random_list_of_nums)
```

![](_attachments/bd4d760944f6cd7f418ff7cbfaef9fd4.gif)

---

Сложность алгоритма:

- O(n²)

---

### Сортировка выборкой

```python
def selection_sort(nums):
	# Значение i соответствует кол-ву отсортированных значений
	for i in range(len(nums)):
		# Исходно считаем наименьшим первый элемент
		lowest_value_index = i
		# Этот цикл перебирает несортированные элементы
		for j in range(i + 1, len(nums)):
			if nums[j] < nums[lowest_value_index]:
				lowest_value_index = j
		# Самый маленький элемент меняем с первым в списке
		nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]


if __name__ == '__main__':
	random_list_of_nums = [5, 2, 1, 8, 4]
	selection_sort(random_list_of_nums)
	print(random_list_of_nums)

```

![](file:///mnt/dowload/Selection-Sort-Animation.gif)

---

Сложность алгоритма:

- O(n²)

---

### Сортировка вставками

```python
def insertion_sort(nums):
	# Сортировку начинаем со второго элемента, т.к. считается, что первый элемент уже отсортирован
	for i in range(1, len(nums)):
		item_to_insert = nums[i]
		# Сохраняем ссылку на индекс предыдущего элемента
		j = i - 1
		# Элементы отсортированного сегмента перемещаем вперёд, если они больше
		# элемента для вставки
		while j >= 0 and nums[j] > item_to_insert:
			nums[j + 1] = nums[j]
			j -= 1
		# Вставляем элемент
		nums[j + 1] = item_to_insert


if __name__ == '__main__':
	random_list_of_nums = [5, 2, 1, 8, 4]
	insertion_sort(random_list_of_nums)
	print(random_list_of_nums)

```

![](_attachments/6e67d1c722106442b422ee53e98575b3.gif)

---

Сложность алгоритма:

- O(n²)

---

### Сортировка слиянием

```python
def merge(left_list, right_list):
	sorted_list = []
	left_list_index = right_list_index = 0

	# Длина списков часто используется, поэтому создадим переменные для удобства
	left_list_length, right_list_length = len(left_list), len(right_list)

	for _ in range(left_list_length + right_list_length):
		if left_list_index < left_list_length and right_list_index < right_list_length:
			# Сравниваем первые элементы в начале каждого списка
			# Если первый элемент левого подсписка меньше, добавляем его
			# в отсортированный массив
			if left_list[left_list_index] <= right_list[right_list_index]:
				sorted_list.append(left_list[left_list_index])
				left_list_index += 1
			# Если первый элемент правого подсписка меньше, добавляем его
			# в отсортированный массив
			else:
				sorted_list.append(right_list[right_list_index])
				right_list_index += 1

		# Если достигнут конец левого списка, элементы правого списка
		# добавляем в конец результирующего списка
		elif left_list_index == left_list_length:
			sorted_list.append(right_list[right_list_index])
			right_list_index += 1
		# Если достигнут конец правого списка, элементы левого списка
		# добавляем в отсортированный массив
		elif right_list_index == right_list_length:
			sorted_list.append(left_list[left_list_index])
			left_list_index += 1

	return sorted_list


def merge_sort(nums):
	# Возвращаем список, если он состоит из одного элемента
	if len(nums) <= 1:
		return nums

	# Для того чтобы найти середину списка, используем деление без остатка
	# Индексы должны быть integer
	mid = len(nums) // 2

	# Сортируем и объединяем подсписки
	left_list = merge_sort(nums[:mid])
	right_list = merge_sort(nums[mid:])

	# Объединяем отсортированные списки в результирующий
	return merge(left_list, right_list)


if __name__ == '__main__':
	random_list_of_nums = [5, 2, 1, 8, 4]
print(f"{merge_sort(random_list_of_nums)}")

```

![](_attachments/Merge-sort-example-300px.gif)

---

Сложность алгоритма:

- O(n log n)

---

### Быстрая сортировка

```python
def partition(nums, low, high):
	# Выбираем средний элемент в качестве опорного
	# Также возможен выбор первого, последнего
	# или произвольного элементов в качестве опорного
	pivot = nums[(low + high) // 2]
	i = low - 1
	j = high + 1
	while True:
		i += 1
		while nums[i] < pivot:
			i += 1

		j -= 1
		while nums[j] > pivot:
			j -= 1

		if i >= j:
			return j

		# Если элемент с индексом i (слева от опорного) больше, чем
		# элемент с индексом j (справа от опорного), меняем их местами
		nums[i], nums[j] = nums[j], nums[i]


def quick_sort(nums):
	# Создадим вспомогательную функцию, которая вызывается рекурсивно
	def _quick_sort(items, low, high):
		if low < high:
			# Это индекс после разворота, на который разбиваются наши списки.
			split_index = partition(items, low, high)
			_quick_sort(items, low, split_index)
			_quick_sort(items, split_index + 1, high)

	_quick_sort(nums, 0, len(nums) - 1)


if __name__ == '__main__':
	random_list_of_nums = [5, 2, 1, 8, 4]
	quick_sort(random_list_of_nums)
	print(random_list_of_nums)

```


![](_attachments/b1xbvefydxsfynp91mnxaxluvfe.gif)



---

Сложность алгоритма:

- O(n log n)

---

### TimSort

TimSort изобретен в 2002 году Тимом Петерсом.
С тех пор он уже стал стандартным алгоритмом сортировки в Python, OpenJDK 7 и Android JDK

![](_attachments/a070140e860a9fe762a1596e24f9c4e9.png)

```python
from pprint import pprint


class TimSort:

	@staticmethod
	def sort(array: list):

		min_run = 32
		n = len(array)
		# Начните с нарезки и сортировки небольших порций
		# входной массив. Размер этих срезов определяется
		# размер вашего `min_run`.
		for i in range(0, n, min_run):
			TimSort.__insertion_sort(array, i, min((i + min_run - 1), n - 1))
		# Теперь вы можете начать объединение отсортированных фрагментов.
		# Начать с min_run, увеличивая размер вдвое
		# каждую итерацию, пока вы не превысите длину
		# массив.
		size = min_run
		while size < n:
			# Определить массивы, которые будут
			# быть объединенными
			for start in range(0, n, size * 2):
				# Вычислить среднюю точку (где заканчивается первый массив
				# и второй запуск) и ʻendpoint` (где
				# второй массив заканчивается)
				midpoint = start + size - 1
				end = min((start + size * 2 - 1), (n - 1))
				# Объединить два подмассива.
				# Массив `left` должен идти от` start` до
				# `midpoint + 1`, а массив` right` должен
				# перейти от `midpoint + 1` к ʻend + 1`.
				merged_array = TimSort.__merge(
						left=array[start:midpoint + 1],
						right=array[midpoint + 1:end + 1])
				# Наконец, поместите объединенный массив обратно в
				# ваш массив
				array[start:start + len(merged_array)] = merged_array
			# Каждая итерация должна удваивать размер ваших массивов
			size *= 2
		return array

	@staticmethod
	def __insertion_sort(array, left=0, right=None):
		if right is None:
			right = len(array) - 1
		# Цикл от элемента, обозначенного
		# `left` до элемента, обозначенного` right`
		for i in range(left + 1, right + 1):
			# Это элемент, который мы хотим разместить в
			# правильное место
			key_item = array[i]
			# Инициализировать переменную, которая будет использоваться для
			# найти правильную позицию указанного элемента
			# by `key_item`
			j = i - 1
			# Просмотрите список элементов (слева
			# часть массива) и найдите правильную позицию
			# элемента, на который ссылается `key_item`. Сделай это только
			# если `key_item` меньше, чем соседние значения.
			while j >= left and array[j] > key_item:
				# Сдвинуть значение на одну позицию влево
				# и переместите `j`, чтобы указать на следующий элемент
				# (справа налево)
				array[j + 1] = array[j]
				j -= 1
			# Когда вы закончите сдвигать элементы, установите
			# `key_item` в правильном месте
			array[j + 1] = key_item
		return array

	@staticmethod
	def __merge(left, right):
		# Если первый массив пуст, то ничего не нужно
		# для объединения, и вы можете вернуть второй массив в качестве результата
		if len(left) == 0:
			return right
		# Если второй массив пуст, то ничего не нужно
		# для объединения, и вы можете вернуть первый массив как результат
		if len(right) == 0:
			return left
		result = []
		index_left = index_right = 0
		# Теперь перебираем оба массива, пока все элементы
		# превратить его в результирующий массив
		while len(result) < len(left) + len(right):
			# Элементы необходимо отсортировать, чтобы добавить их в
			# результирующий массив, поэтому вам нужно решить, получать ли
			# следующий элемент из первого или второго массива
			if left[index_left] <= right[index_right]:
				result.append(left[index_left])
				index_left += 1
			else:
				result.append(right[index_right])
				index_right += 1
			# Если вы дойдете до конца любого массива, вы можете
			# добавляем оставшиеся элементы из другого массива в
			# результат и разорвать цикл
			if index_right == len(right):
				result += left[index_left:]
				break
			if index_left == len(left):
				result += right[index_right:]
				break
		return result


if __name__ == '__main__':
	random_list_of_nums = [
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			5, 2, 1, 8, 4,
			]

	TimSort.sort(random_list_of_nums)
	pprint(random_list_of_nums, width=40, compact=True)

```

---

Сложность алгоритма:

- O(n log n)

---

## Закрепление:

### !

==Задача== Перечислите алгоритмы сортировоки

# Алгоритмы шифрования

## Теория

## Криптографическое хеширование

### SHA-256




## Закрепление

### !
