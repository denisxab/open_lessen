- 1 Неделя
    - Тема 1 - 5.1
    - Тема 5.2

---

- 2 Неделя

    - Тема 6-7
    - Тема 8-11

---

- 3 Неделя

    - ООП
    - Структуры данных (бинарные деревья, хеш таблицы)

---

- 4 Неделя

    - Графы, Асимптотика алгоритмов и сортировок
    - Обработка исключений, паттерны проектирования

---

- 5 Неделя

    - Процессы, потоки, асинхронность
    - Как устроенны сети

---

- 6 Неделя

    - Сериализация, стандартные типы файлов
    - Фреймворк Django

---

- 7 Неделя
    - Фреймворк Django
    - Баззы данных в django

---

- 8 Неделя

    - SQL запросы
    - Регулярные выражения, unit-test

---

- 9 Неделя
    - Процесс разработки ПО

---

# Тема 1. Настройка IDE

## Теория:

Вы можете писать код хоть в тетрадки, а потом переписывать его в Блокнот `Windows`,но не очень удобно.
![](_attachments/6ad3f31735dcbe5310b1cac0e573e105.png)

Для того чтобы программистом было удобно писать код, они придумали `IDE`

---

Разберемся с тем что такое `IDE` ? `IDE` Переводиться как "Интегрированная среда разработки" она нужна для того чтобы:

- => Писать в ней код.
- => Использовать различные полезные программы, в удобном интерфейсе (Проводник, Терминал, `Git`, Отладчики, `UnitTest`, `pip`, др...).
- => Получать подсказки в коде. (Автодополнения, Всплывающая документация, Подсветку ошибок)

В итоге - когда мы пользуемся `IDE`:

1. Мы в одной программе можем пользоваться всеми нужными инструментами.
1. Также мы будем меньше совершаем глупые ошибки в коде, потому что `IDE` будет нам подсказывать.
1. Нам не нужно задумываться об отступах и пробелах, потому что `IDE` может красиво отформатировать наш код, по стандартам `PEP 8`.

Также приятно писать код в `IDE`, потому что его интерфейс можно подстроить под себя
(Выбрать: Цветовую палитру, Черную или Белую тему. Стиль шрифта, установить сторонние плагины).

---

<p align="center" style="font-size:20px">
	`IDE` нужно для того чтобы быстро и качественный писать код.
</p>

---

Существуют достаточно много инструментов для написания кода. Но самые известные из них это.

- `PyCharm` (+)
- `VS Code`
- `Jupyter Notebook`

![Статистика пользователй IDE](_attachments/b12d3db878b0da11c60058b334a11c7c.png)

---

### Создание проекта и виртуальное окружение

`File -> New Project`

![Создание проекта](_attachments/0425bddbfe083119ab88228b6c3e4c0c.png)

1. Путь где будет находиться проект
2. Путь где будет находиться виртуальное окружение
3. Вы можете использовать уже ранее созданные виртуальное окружения
4. Шаблоны проектов для различных Фреймворков

### Навигация в проекте

Одна из главных особенностей `PyCharm` - это возможность
автоматически изменять пути импортирования модулей при
переносе модуля

![](_attachments/584318a261aebfd76e201d36631fbdf4.png)

- `New` Создать файл по шаблону
- `Copy`Копировать относительный, или абсолютный путь к файлу
- `Show Explorer` Открыть папку в проводнике
- `Open in Terminal` Открывает папку в терминале

## Закрепление

### !

==Задача:== Создать проект с виртуальным окружением, и создать свой первый скрипт на `Python`.

```python
print("Hello world")
```

# Тема 2. Базовый синтаксис

## Тема 2.1. Как устроен `Python`

### Теория

#### Общий исторический экскурс

- С начало была пустота

- В 1848 `Джордж Буль` создал новый раздел в математике - булева алгебра
    Он открыл основные булевые операциями: конъюнкция (И), дизъюнкция (ИЛИ), отрицание (НЕ).

- В 1936 была предложена Маши́на Тью́ринга для формализации понятия алгоритма.

    1.  Читать | Записывать данные
    2.  Передвигать указатель. В начало и конец.
    3.  Выполнять все логические операции. Например, полную болевую функцию (конъюнкция, дизъюнкция, отрицание).
        Теореме Поста утверждает что с помощью полной булевой функции можно выразить любую логическую операцию.

    ![](_attachments/79e82e30511dddca240e3bed8afb5b8d.png)

    Для того чтобы как то хранить программу программисты придумали просто писать `01`

- В 1949 был создан Язык ассемблер - машинно-ориентированный язык программирования низкого уровня.

- В 1972 был создан Си (язык программирования)

- В 1983 С++

- в 1991 Python

- В 1995 Java

- В 1995 JavaScript

- В 2002 С#

- В 2010 `Rust`

- В 2009 `Go`

- В 2011 `Kotlin`

- В 2012 `TypeScript`

Все языки программирования могут одно и тоже

```python
import math

if __name__ == '__main__':
	print("Сторонние библиотеки\t\t\t\t\t\t\t\t", math.pow(3, 3))
	print("Встроенная функция\t\t\t\t\t\t\t\t\t", pow(3, 3))
	print("Стандартный арифметический оператор\t\t\t\t\t", 3 ** 3)
	# ------ #
	print("Выражение степени через умножение\t\t\t\t\t", 3 * 3 * 3)
	# ------ #
	print("Выражение умножения через сложение\t\t\t\t\t", 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3 + 3)
	# ------ #

	"""
	Суммировать числа с помощью логических операторов

	00011 = 3
	00011
	-----
	00110 = 6
	00011
	-----
	1001 = 9
	0011
	-----
	1111 = 12
	0011
	-----
	10010 = 15
	00011
	-----
	10101 = 18
	00011
	-----
	10101 = 21
	00011
	-----
	11000 = 24
	00011
	-----
	11011 = 27
	"""
	print("Суммировать числа, через условне операторы\t", int(b"11011", 2))

```

---

#### История языка `Python`, сравнение его с другими языками программирования, сфера его использования.

Первая версия Python создан в 1991, разработчиком по имени **Гвидо ван Россу**,
это название язык получил в память британского комика Monty Python. В 1994 году была создана первая версия интерпретатора `CPython`.

---

Основной конкурент `Python` это `Java` и `C#`. Чем `Python` лучше ?

- Изначально создан для удобного использования.
    Существует `Python Zen` и `PEP 8`, которые нужны дя того чтобы, все разработчики писали понятны код.
- Самое активное комьюнити в РФ.

    ![@MotherSearchBot](_attachments/d2ab300f24e11ef3c0554bf45b34efda.png)

- Более 1 миллиона проектов на GitHab

    ![Python_Java_C#](_attachments/dee5ec7192eec7a0b8badb302589cb09.png)

- `Python`Язык который развивается сообществом.
- На 2019 год более 179 тысяч официальных библиотек для `Python`, и более 106 тысячи из них распространяется по открытой или
    либо свободной лицензии [+](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3426281)

- Постоянно развивается

    ![](_attachments/32999170d3fa3cf1f34c42d7633821a8.png)

---

Где используется ?

1. Веб-разработка

- `Django` (свободный фреймворк для веб-приложений на языке Python)
- `Flask` (микрофреймворков)

2. Data Analysis

- `Numpy` (Для работы с математическими вычислениями) [+](https://ru.wikipedia.org/wiki/NumPy)
- `Pandos` (Визуализация данных в виде таблиц) [+](https://ru.wikipedia.org/wiki/Pandas)
- `matplotlib` (Построение графиков)[+](https://ru.wikipedia.org/wiki/Matplotlib)

3. ML

- `keras`
- `tensorflow`

3. Создания прикладных приложений или игр.

- `wxPython`
- `PyQt`
- `Godot`

4. Системное администрирование

- `sh`
- `subprocess`

[Остальные 92 области в которых применяться Python](https://github.com/vinta/awesome-python#http-clients)

---

#### Характеристика `Python`.

1. Динамический язык

Не Динамический `C++`

```c++
#include <iostream>
#include <typeinfo>

using namespace std;

int main()
{

   int a = 10;

    std::cout << a << std::endl; // 10
    std::cout << "Тип:" <<typeid(a).name() << std::endl; // Тип:int

    a = '1';

    std::cout << a << std::endl; // 49
    std::cout << "Тип:" <<typeid(a).name() << std::endl; Тип:int

    return 0;
}

```

```c++
#include <iostream>
#include <typeinfo>

using namespace std;

int main()
{

   char a[] = "10";

    std::cout << a << std::endl;
    std::cout << "Тип:" <<typeid(a).name() << std::endl;

    a = 10; // ошибка: несовместимые типы при присвоении 'int' char [3] '

    std::cout << a << std::endl;
    std::cout << "Тип:" <<typeid(a).name() << std::endl;

    return 0;
}
```

Динамический `Python`

```python
a = 10
a = 10.1
a = False
a = "10"
a = [1,2,3]
```

2.  Cо строгой типизацией.

Не строгая типизация `JavaScript`

```js
a = 1
b = "10"

с = a+b # Все Ок

console.log(c) # "110"
```

Строгая типизация `Python`

```python
a = 1
b = "10"

c = a + b # TypeError: unsupported operand type(s) for +: 'int' and 'str'

print(c)
```

3. Автоматически управляет памятью.

Управлять памятью в ручную `C++`

```c++
#include <iostream>

using namespace std;

int main()
{
    int *p_var = nullptr;  // объявление нового указателя
    p_var = new int;       // память динамически выделяется


    cout << *p_var << endl;// 0
    *p_var = 10;
    cout << *p_var << endl;// 10



    delete p_var;          // память освобождается
    p_var = nullptr;       // указатель заменяется на нуль-указатель

    return 0;
}
```

Автоматически управляет памятью `Python`

```python
a = 10
```

4. Объектно-ориентированный.

Функциональный

```c
struct User{
	...
}

void User_Construct(*this){
	...

}

void User_get_name(*this){
	...
}
```

Объектно-ориентированный

```python
class User():
	def __init__(self):
		...

	def get_name(self):
		...
```

5. Интерпретируемый
    - В стандартной реализации `CPython`
    - С возможностью компилляции в машинный код через `Nuitka` `Cython` `Numba`.
    - С возможность JIT компиляции в реализации `PyPy`.
    - `Jython` в `JVM`;
    - `IronPython` в `Microsoft .NET`

---

==Задача:== Каким является `Python` ?

---

#### Разница между компилируемым и интерпретируемым языком.

##### Компилируемым:

Все языки программирования компилируются по-разному, но их всех объединяет следующие факты.

- Скомпилированные программы могут самостоятельно исполняться. (`.exe`).
- Под каждую архитектуры процессора и ОС, нужно компилировать свой исполняемый файлы. (`.exe` VS `.so`).
- Требует время на процесс компиляции. (Например компиляция `MySql` составляет 3 часов, ядра Linux 1 часа).

> Этапы сборки:
>
> -   Препроцессинг: (%1)
>
>     -   Удалить комментарии
>     -   Выполнить макросы (Вставить или убрать кусок кода)
>
> -   Компилляция: (%1)
>
>     -   Проверка синтаксиса.
>     -   Все кроме названия функций переводиться в ассемблер => объектный файл
>
> -   Сборка исполняемый файл: (%98)
>     -   Весь файлы который используется в программе cоединяются в один, и переводится в машинный код.

1. `C`
2. `C++`
3. `Go`
4. `Rust`
5. `Swift`
6. `Fortran`

##### Интерпретируемым:

- Если на платформе установлен интерпретатор `Python`, то на нем можно запустить любой код на `Python`.
- Меньший размер исполняемых файлов файл. `.py` это и есть исполнимый файл. (Сам интерпретатор весит 14 мб).
- Не нужно ждать компиляции, так как инструкции выполняются в реальном времени.

> 1.  Игнорирует комментарии, и проверяется синтаксис языка текущем файле.(Закрытие скобки, количество отступов, ...тд)
> 2.  Если встречается функция. Запоминаем => имя функции, имена переменных и их константные значения, переводиться в байт-код для `CPython`.
> 3.  Если встречается класс. Запоминаем => имя класса, статичные имена переменных и их константные значения, методы класса работают так же как и `2`, переводиться в байт-код для `CPython`.
> 4.  Если встречается инструкция, то она переводиться в байт-код для `CPython`.
> 5.  Если встречается импорт модуля. То выполняются 1,2,3,4. => Добавляем данные в глобальные

1. `Python`
2. `PHP`
3. `JavaScript`
4. `Ruby`
5. `Perl`

##### Компилируемые в байт-код.

- Код не может запускаться без виртуальной машинны.
- Требует время на компилляцию. (для оптимизации кода)

1. `Java`
1. `Kotlin`
1. `Jython`
1. `C#`

### Закрепление

#### !

---

==Задача:== Какая разница между компиляцией и интерпретацией ?

---

## Тема 2.2. Числа

### Теория:

#### Целые числа `int`

Пример.

```python
a = 77
b = 23
print(a+b)

#> 100
```

---

- В `Python` нет ограничений на максимально число которое можно записать в `int`.
- Но. Изначально в `int` можно записать число не больше `9_223_372_036_854_775_807` (Девять квинтиллионов) это равно `2^63`.
- Но при этом, как только значение в `int` превышает `9_223_372_036_854_775_807`, `Python` выделяет новый участок памяти и копирует в него текущее значение.

---

==Вопрос==: Почему изначально максимальное значение в `int` является не четная степень двойке?

---

Пример отсутствия ограничений `Python`

```python
a = 9_223_372_036_854_775_807
a += 10
print(a)

# 9223372036854775817 (Девять квинтиллионов)



a = 9_223_372_036_854_775_807
a *= 9_223_372_036_854_775_807
print(a)

# 85070591730234615847396907784232501249 (Восемьдесят пять ундециллионов)
```

Проверим другой язык. Аналог `int` в `C` это `long long`

```c++
#include <iostream>

using namespace std;

int main()
{
    long long a = 9223372036854775807;

    cout << a <<'\n'; // 9223372036854775807;

    a += 10;

    cout << a; // -9223372036854775799;
    return 0;
}
```

![](_attachments/c2241713608d91a62fab11f29f3e4dfa.png)

#### Число с плавующей точкой `float`

Пример.

```python
a:float= 0.4
b:float = 0.9

print(a+b)

#> 1.3
```

---

Проблемы с точностью после запятой

```python
a:float= 0.1
b:float = 0.2

print(a + b)

#> 0.30000000000000004
```

```python
>>> 9223372036854775808 ** 1/63
1.464027307437266e+17
```

Решение проблемы точности после запятой.

- Использовать встроенную библиотеку `Decimal`(Децимал)

```python
from decimal import Decimal

a: Decimal = Decimal("0.1")
b: Decimal = Decimal("0.2")
print(a + b)

#> 0.3
```

- Использовать встроенные функции при работе с `float`

```python
>>> pow(9223372036854775808,1/63)
2.0
```

### Закрепление

#### !

Подсчитать сколько вам сейчас месяцев

> ```python
> # Сколько мне месяцев
>
> if __name__ == "__main__":
> 	old: float = 21.7
> 	print(old * 12)
>
> 	old: int = 21
> 	full_month: int = 7
> 	print(old * 12 + full_month)
> ```

[Сайт на котором проверить Проверить](http://mycount.org/ru/?wm=3&inv=1&fid=6)

# Тема 3. Переменные, типы переменных. Типизация.

## Теория

### `immutable`

К не изменяемые типам данным, относятся простые значения такие как:

- `int`
- `float`
- `bool`
- `None`

```python
if __name__ == "__main__":
	a = 3
	b = a # Теперь и `b` и `a` указывает на один и тот же участок памяти

	print(f'a: {a} | id: {id(a)}') # a: 3 | id: 139746148944240
	print(f'b: {b} | id: {id(b)}') # a: 3 | id: 139746148944240

	b = 0 # Изменение `b` не влияет на `a`

	print(f'a: {a} | id: {id(a)}') # a: 3 | id: 139746148944240
	print(f'b: {b} | id: {id(b)}') # b: 0 | id: 139746148944144
```

![](_attachments/9964e7c62fe54e162c2012ba0cc7584e.png)

---

Также к ним отгостятся `не изменяемы массив`

- `tuple`

```python
if __name__ == "__main__":
	a = (5, 3, 2, 7)
	b = a  # Теперь и `b` и `a` указывает на один и тот же участок памяти

	print(f'a: {a} | id: {id(a)}')  # a: 3 | id: 139746148944240
	print(f'b: {b} | id: {id(b)}')  # a: 3 | id: 139746148944240

	print(f"\nb[0]: {b[0]}\n") # 5

	b = 0  # Изменение `b` не влияет на `a`

	print(f'a: {a} | id: {id(a)}')  # a: 3 | id: 139746148944240
	print(f'b: {b} | id: {id(b)}')  # b: 0 | id: 139746148944144

	b[0] = "H" # TypeError: 'str' object does not support item assignment

```

![](_attachments/0ee879c3d16a71a68b4586b3c702dade.png)

Как устроенна навигация по индексам

- ![](_attachments/bfa61c21b3c75a68e5fe595308fd9a40.png)
- ![](_attachments/d68130b81faa496a376640756a26862f.png)
- ![](_attachments/b6cf1984dbd47e7c438a2a30816a005f.png)
- ![](_attachments/b3f3e884b7dae87055b16ec3d295005d.png)
- ![](_attachments/5b04b0693ebdc607e9a6c68116e38f72.png)
- ![](_attachments/3c862a25033cd6213950ea8baf10d9c9.png)
- ![](_attachments/3b1c3726ee75b95a2d99267c324e749c.png)

---

==Задача:==
Создать `не изменяемый массив` на 8 элементов, любого типа, и подсчитать сумму всех элементов в массиве. (Запомнить это Задача)

> ```python
> a = (1, 2, 3, 4, 5, 6, 7, 8)
>
> print(a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7])
> print(sum(a))
> ```

---

Строки тоже не изменяемые тип данных

- `str`
- `bytes`

![](_attachments/1a4ba292b8c4c633d381ee5dcea96830.png)

- ![](_attachments/b88425183b81fe55489e40735c5f7a89.png)
- ![](_attachments/edfb072afbdf929d15588cd3f8ff7ba8.png)
- ![](_attachments/9b1f870c1b85cc0fd6b251d9760982ff.png)

---

==Задача:== Создать строку, в которой храниться выше имя. И записать её наоборот в `tuple` (Запомнить это Задача)

```python
"denis" -> ("s","i","n","e","d")
```

> ```python
> t = (name[4], name[3], name[2], name[1], name[0])
> print(t)
> ```

---

Мы не можем изменить элемент, но мы можем сделать копию, и добавить в нее новый элемент.

```python
if __name__ == "__main__":
	a = (5, 3, 2, 7)
	b = (96,)


	print(f'a: {a} | id: {id(a)}')  # a: (5, 3, 2, 7)  	| id: 140655119831104 (Изначально ID)
	print(f'b: {b} | id: {id(b)}')  # b: (96,)  		| id: 139834492989600

	print(f"\nb: {b}\n")# b[0]: 96

	a += b

	print(f'a: {a} | id: {id(a)}')  # a: 3 | id: 139834492712336 (Теперь ID != изначальному ID)
	print(f'b: {b} | id: {id(b)}')  # b: 0 | id: 139834492989600

```

- ![](_attachments/29c85b427699291287b22f999a9f7283.png)
- ![](_attachments/7143df13014ad3a6a37945fced19ea8f.png)

---

==Задача:== У нас есть компания. В которой на постоянной основе работают 5 человек.
Мы храним `имя` `должность` `телефонный номер` каждого работника компании в неизменяемом массиве.
Сегодня в нашу компанию приняли нового работника, и теперь наша задача
**Добавить нового работника в наш неизменяемый массив.** (Запомнить это Задача)

> ```python
> if __name__ == '__main__':
> 	a = (
> 			("Денис", "Повар", 899423323),
> 			("Олег", "Повар", 899233323),
> 			("Сережа", "Повар", 891923323),
> 			("Дима", "Повар", 899233423),
> 			)
>
> 	b = ("Настя", "Менеджер", 89999091)
>
> 	print(a)
> 	a += (b, )
> 	print(a)
> ```

---

### `mutable`

К изменяемые типам данным относятся:

- `list` Список.

```python
if __name__ == "__main__":
	a = [3]
	b = a  # Теперь и `b` и `a` указывает на один и тот же участок памяти

	print(f'a: {a} | id: {id(a)}') a: [3] | id: 140415028741888
	print(f'b: {b} | id: {id(b)}') b: [3] | id: 140415028741888

	b = 0 # Изменение `b` не влияет на `a`

	print(f'a: {a} | id: {id(a)}') a: [3] | id: 140415028741888
	print(f'b: {b} | id: {id(b)}') b:   0 | id: 140415030360336

```

- ![](_attachments/95c543c59a0c39a38882b398381855ca.png)

```python
if __name__ == "__main__":
	a = [5, 3, 2, 7]
	b = a # Теперь и `b` и `a` указывает на один и тот же участок памяти

	print(f'a: {a} | id: {id(a)}') # a: [3] | id: 140038025479936
	print(f'b: {b} | id: {id(b)}') # b: [3] | id: 140038025479936

	b[0] = "H" # Изменение элеманта в  `b`  изменяет элемент в `a`

	print(f'a: {a} | id: {id(a)}') # a: [0] | id: 140038025479936
	print(f'b: {b} | id: {id(b)}') # b: [0] | id: 140038025479936
```

- ![](_attachments/3c862a25033cd6213950ea8baf10d9c9.png)
- ![](_attachments/dcbdc36c516a322e4c34b9dad4ed5900.png)
- ![](_attachments/3b1c3726ee75b95a2d99267c324e749c.png)

На счет `str` и `tuple`

```python
if __name__ == "__main__":
	a = "hello"
	b = a

	print(id(a))
	print(id(b))

	b[0] = "H" # TypeError: 'str' object does not support item assignment
```

```python
if __name__ == "__main__":
	a = (1, 2, 3)
	b = a

	print(id(a))
	print(id(b))

	b[0] = "H"  # TypeError: 'str' object does not support item assignment

```

---

==Задача== У нас есть пустой массив. `allworkers = []`, на нужно добавить в него все значения,
из `неизменяемого массива`, который мы создали на прошлом задании.

> ```python
> if __name__ == '__main__':
> 	a = (
> 			("Денис", "Повар", 899423323),
> 			("Олег", "Повар", 899233323),
> 			("Сережа", "Повар", 891923323),
> 			("Дима", "Повар", 899233423),
> 			)
>
> 	b = ("Настя", "Менеджер", 89999091)
>
> 	print(a)
> 	a += (b,)
> 	print(a)
>
> 	allworkers = []
> 	allworkers.append(a[0])
> 	allworkers.append(a[1])
> 	allworkers.append(a[2])
> 	allworkers.append(a[3])
> 	allworkers.append(a[4])
>
> 	print(allworkers)
> ```

---

Также к изменямым типам данных относятся:

- `dict` Словарь.
- `set` Множество. (На следующем занятие)

```python
if __name__ == "__main__":
	a = {
			"Паша"     : 4,
			"Маша"     : 5,
			"Вова"     : 4,
			"Инокентий": 3,
			}

	b = 0

	print(f'a: {a} | id: {id(a)}')  # a: ... | id: 140646365602304
	print(f'b: {b} | id: {id(b)}')  # b: ... | id: 140365836163344

	print(a["Паша"])  # 4
	print(a["Маша"])  # 5
	print(a["Инокентий"])  # 3

	b = a

	print(f'a: {a} | id: {id(a)}')  # a: ... | id: 140646365602304
	print(f'b: {b} | id: {id(b)}')  # b: ... | id: 140646365602304

	print(b["Паша"])  # 4
	print(a["Паша"])  # 4
	print(b["Вова"])  # 4

	b["Паша"] = 1

	print(b["Паша"])  # 1
	print(a["Паша"])  # 1

	print(f'a: {a} | id: {id(a)}')  # a: ... | id: 140646365602304
	print(f'b: {b} | id: {id(b)}')  # b: ... | id: 140646365602304

	################################


	a["Света"] = None

	print(a) # {'Паша': 1, 'Маша': 5, 'Вова': 4, 'Инокентий': 3, 'Света': None}
	print(b) # {'Паша': 1, 'Маша': 5, 'Вова': 4, 'Инокентий': 3, 'Света': None}
```

---

==Задача== Мы разрабатываем социальную сеть, и нам нужно хранить следующие данные о пользователе:

- ID
- Ник
- Имя
- Год рождения
- Статус (Онлайн/не онлайн)

Реализовать хранение данных в типе `dict`

> ```python
> a = {
> 		"id"      : 1,
> 		"nic"     : "dinis",
> 		"name"    : "Denis",
> 		"birthday": 2000,
> 		"status"  : 1,
> 		}
> ```

---

### Aннотация типов

```python
a:int = 0
b:float = 0.0
c:str = "Hello"


t:tuple = (1,2,3,)
d:dict = {
	1:1,
	2:4,
	"hello":0.0,
}
```

## Закрепление:

### !

Давайте подытожим то что сказанною в этой теме.

`immutable`

- `int`Челые числа
- `float` Числа с плавающей точкой
- `bool`Логические переменные
- `str` Строки символом `UTF-8`
- `bytes` Строка байт
- `None` Отсутствие
- `tuple` Картежи

`mutable`

- `list` Список. Непрерывный участок памяти
- `set` Множество
- `dict` Словарь

# Темы 3.1. Основные арифметические операции

## Теория:

### Таблица с арифметическими операциями

| Знак     | Вызываемый метод | Описание              |
| -------- | ---------------- | --------------------- |
| `a + b`  | `__add__`        | Сложение              |
| `a - b`  | `__sub__`        | Вычитание             |
| `a * b`  | `__mul__`        | Умножение             |
| `a / b`  | `__truediv__`    | Деление               |
| `a // b` | `__floordiv__`   | Целочисленное деление |
| `a % b`  | `__mod__`        | Остаток от деления    |
| `a ** b` | `__pow__`        | Возведение в степень  |

```python
a = 13
b = 7

a = a+b # 20
```

| Знак      | Вызываемый метод |
| --------- | ---------------- |
| `a += b`  | `__iadd__`       |
| `a -= b`  | `__isub__`       |
| `a *= b`  | `__imul__`       |
| `a /= b`  | `__itruediv__`   |
| `a //= b` | `__ifloordiv__`  |
| `a %= b`  | `__imod__`       |
| `a **= b` | `__ipow__`       |

```python
a = 13
b = 7

a+=b # 20
```

---

==Задача:== Как взять квадратный корень из числа 25 ?

> ```python
> num = 25
> sqrt = num ** 0.5
>
> print(sqrt) # 5.0
> ```

---

## Закрепление.

### !

==Задача:== Создать алгоритм для расчета длинны гипотенузы, используя теорему Пифагора.

![](_attachments/696790e3d7560d1e92a01805fa0b5817.png)

> a^2 + b^2 = c^2

> ```python
> a = 3
> b = 4
> c2 = a ** 2 + b ** 2
> c = c2 ** 0.5
> print(c)
> ```

---

==Задача:== Задача по физики.

| Дано                                            | Вопрос                                                                             |     |
| ----------------------------------------------- | ---------------------------------------------------------------------------------- | --- |
| Расстояние от Солнца до Земли: `149_600_000` км | Сколько времени потребуется свету, чтобы преодолеть дистанцию от Солнца до Земли ? |     |
| Скорость света: `299_792_458` м/c               |                                                                                    |     |

> ```python
> # Сколько времени потребуется свету, чтобы преодолеть дистанцию от Солнца до Земли
>
> # 1км == 1000м
>
> if __name__ == '__main__':
> 	Earth_kilometers = 149_600_000
> 	speed_light_meter_second = 299_792_458
> 	a = Earth_kilometers * 1000
>
> 	print(a) # 149600000000
>
> 	c = a / speed_light_meter_second
> 	print(c) # 499.01188641643546
>
> 	c /= 60
> 	print(c) # 8.316864773607257
> ```

---

# Тема 4. Условные конструкции

## Теория:

### Виды логических операций

| Знак     | Вызываемый метод | Описание                          |
| -------- | ---------------- | --------------------------------- |
| `a == b` | `__eq__`         | Равенство значений                |
| `a != b` | `__ne__`         | Неравенство значений              |
| `a >= b` | `__ge__`         | Больше или равно                  |
| `a <= b` | `__le__`         | Меньше или равно                  |
| `a > b`  | `__gt__`         | Больше                            |
| `a < b`  | `__lt__`         | Меньше                            |
| `a is b` |                  | Указывают на один и тот же объект |
| `a in b` | `__contains__`   | Значение `a` есть в массиве `b`   |
|          |                  |                                   |

---

Пример `a == b`

```python
a = 1
b = 1

print((a == b)) # True
print((a is b))	# True

print(id(a)) # 140569467918640
print(id(b)) # 140569467918640
```

Пример `a is b`

```python
a = [1]
b = [1]

print((a == b)) # True
print((a is b)) # False


print(id(a)) # 140380746996800
print(id(b)) # 140380743800320
```

---

==Задача== Вспомнить или догадаться о таблице истинности.

> Таблица истинности
>
> | a   | b   | and   | or    | !a  | !b  |
> | --- | --- | ----- | ----- | --- | --- |
> | 0   | 0   | **0** | **0** | 1   | 1   |
> | 0   | 1   | **0** | **1** | 1   | 0   |
> | 1   | 0   | **0** | **1** | 0   | 1   |
> | 1   | 1   | **1** | **1** | 0   | 0   |

---

### Стандартный условный оператор.

```python
if <Выражение1 Выражение2 ... Выражение3>:
	...

elif <Выражение1 Выражение2 ... Выражение3>:
	...

else:
	...
```

Пример где применять стандартный условный оператор.

```python
# Двери на склaде
if __name__ == '__main__':
	total_doors_warehouse = -1

	if total_doors_warehouse >= 1:
		print("Двери есть в наличии")

	elif total_doors_warehouse < 0:
		raise ValueError("Отрицательно количество дверей")

	else:
		print("Дверей нет в наличии")
```

---

==Задача== Создать калькулятор для двух чисел. который умеет (`+`, `-`, `*`,`/`)

```python
"1+2" = 3
"5-1" = 4
"3*2" = 6
"8/2" = 4
```

> ```python
> if __name__ == '__main__':
> 	response = "8/2"
> 	res = 0
>
> 	if response[1] == '+':
> 		res = int(response[0]) + int(response[2])
>
> 	if response[1] == '-':
> 		res = int(response[0]) - int(response[2])
>
> 	if response[1] == '*':
> 		res = int(response[0]) * int(response[2])
>
> 	if response[1] == '/':
> 		res = int(response[0]) / int(response[2])
>
> 	print(res)
> ```

---

### Тернарный условный оператор.

```python
<Ответ> if <Выражение1 Выражение2 ... Выражение3> else <Ответ>
```

Пример где применять тернарный условный оператор.

```python
# Пороговая функции активации

response_neural_network = 0.7

res = 1 if response_neural_network >= 0.5 else 0

print(res) # 1
```

![](_attachments/b969af386b6182028f81995585978eeb.png)

Главная особенность `тернарного оператора` в том,
что мы не можем создавать новые переменные, и изменять существующие. Мы можем только читать данные из переменных.

Но почему тогда работает этот пример ?

```python
if __name__ == '__main__':
	response_neural_network = 0.3

	res = response_neural_network = 1 if response_neural_network >= 0.5 else 0

	print(res)  # 0
	print(response_neural_network)  # 0

```

Потому что это множественное присвоение.

```python
if __name__ == '__main__':
	a = 1
	b = 2
	c = 3
	d = 4

	print(a, b, c, d) # 1 2 3 4

	b = a = c = d = 0

	print(a, b, c, d) # 0 0 0 0

```

---

==Задача== Создать функцию активации `Линейный выпрямитель`

![](_attachments/9fb5c4ba3cefa942e01948a1798c8805.png)

> ```python
> if __name__ == '__main__':
> 	a = 12
> 	res = 0 if a < 0 else a
> 	print(res)
> ```

---

### `assert`

Оператор `assert` используют как простой способ тестирования кода. Суть его работы заключается в следующем.

```python
"""
Мы используем обычные условные операторы, если `выражение` верно то программа продолжает свою работать,
а если `выражение` неверно то у нас вызывается исключение `AssertionError`.

Вся суть заключается в том, что мы можем за одну команду отключать `assert` если он нам не нужен.
"""

if __name__ == '__main__':
	a = 10
	b = 5
	c = a + b
	assert c == 0 # ! AssertionError
	print(c)
```

Использовать флаг `-O` для запуска программы [другие способы](https://ru.stackoverflow.com/questions/743944/%D0%95%D1%81%D1%82%D1%8C-%D0%BB%D0%B8-%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BE%D1%82%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D1%8C-assert)

```python
python -O <ИмяФайла>.py
```

---

==Задача== Попробуйте создать свой первый тест.

---

### `switch case` на `Python`

```python
# Горячие клавиши

ArrHotKey = {
		"Ctrl+C"   : "Копировать текст",
		"Ctrl+V"   : "Вставить текст",
		"Ctrl+X"   : "Вырезать текст",
		"Win+Space": "Копировать текст",
		}

if __name__ == '__main__':
	hotkey = "Ctrl+C

	res = ArrHotKey.get(hotkey, None)

	print(res) if res else  print("Не известная комбинация клавиш")

#[Реальный пример использования](https://github.com/denisxab/keyboard_capture/blob/master/app/logic.py)
```

[Реальный пример использования](https://github.com/denisxab/keyboard_capture/blob/master/app/logic.py)

---

==Задача== Нужно создать поисковик товаров. Например, мы вводим имя товара, и получаем в ответ адрес, где хранится этот товар.

```python
"Холодильник Север" -> "м Лененкий проспект, улица ленина дом 22 корпус 3"
"Кружка с черный квадратом Малевича" -> "Санкт-Петербург, Инженерная ул, Русский музей"
```

> ```python
> a = {
> 		"Холодильник Север"                 : "м Лененкий проспект, улица ленина дом 22 корпус 3",
> 		"Кружка с черный квадратом Малевича": "Санкт-Петербург, Инженерная ул, Русский музей"
> 		}
>
> print(a["Холодильник Север"])
> ```

---

### Что относится к `False`

1. пустой список: `[]`
1. пустой кортеж: `()`
1. пустой словарь: `{}`
1. пустое множество: `set()`
1. пустая строка: `""`
1. целочисленный ноль: `0`
1. ноль с плавающей точкой: `0.0`
1. `None`
1. `False`

```python
if __name__ == '__main__':

	a = []
	if a:
		print("1")

	a = ()
	if a:
		print("2")

	a = {}
	if a:
		print("3")

	a = set()
	if a:
		print("4")

	a = ""
	if a:
		print("5")

	a = 0
	if a:
		print("6")

	a = 0.0
	if a:
		print("7")

```

## Закрепление:

### !

Пример программы для разбора.

```python
# Регистрации пользователя


UpperSymbol =	['Q', 'W', 'E',
				 'R', 'T', 'Y',
				 'U', 'I', 'O',
				 'P', 'A', 'S',
				 'D', 'F', 'G',
				 'H', 'J', 'K',
				 'L', 'Z', 'X',
				 'C', 'V', 'B',
				 'N', 'M', ]

if __name__ == '__main__':
   response_user = input("Введите ваш email: ")
   if "@" in response_user:
      email = response_user
   else:
      exit("Некорректный email")

   response_user = input("Укажите ваш имя  с заглавной буквы: ")
   if response_user[0] in UpperSymbol:
      name = response_user
   else:
      exit("Некорректное имя")

   user = (email, name)
   print(user)

# Введите ваш email: denis@rma
# Укажите ваш имя  с заглавной буквы: Denis
# ('deni@s', 'Denis')
```

---

==Задача:==

Допустим вы разрабатываете форму регистрации на сайте. Сейчас вам нужно создать такой валидатор,
который бы проверял то что в поле с именем нет чисел. (Запомнить это Задача)

```python
"Denis" -> True
"Den4is" -> False
```

> ```python
> if __name__ == '__main__':
> 	NUM = ("0",
> 	       "1",
> 	       "2",
> 	       "3",
> 	       "4",
> 	       "5",
> 	       "6",
> 	       "7",
> 	       "8",
> 	       "9",
> 	       )
> 	name = "Deni9s"
>
> 	if NUM[0] in name:
> 		print("False")
>
> 	elif NUM[1] in name:
> 		print("False")
>
> 	elif NUM[2] in name:
> 		print("False")
>
> 	elif NUM[3] in name:
> 		print("False")
>
> 	elif NUM[4] in name:
> 		print("False")
>
> 	elif NUM[5] in name:
> 		print("False")
>
> 	elif NUM[6] in name:
> 		print("False")
>
> 	elif NUM[7] in name:
> 		print("False")
>
> 	elif NUM[8] in name:
> 		print("False")
>
> 	elif NUM[9] in name:
> 		print("False")
>
> 	else:
> 		print("True")
> ```

---

# Тема 4.1. Циклы. Цикл for, while.

## Теория:

### `for`

```python
for <_item> in <obj.__iter__()>:
	...

	# <obj.__next__()>
```

Пример как можно было бы сделать прошлое Задача с помощью цикла

```python
# Вариатор имени

if __name__ == '__main__':

	name = "Den4is"
	num = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

	for _item in num:
		if _item in name:
			print("Не корректные данные. В имени не должно быть чисел")

	print("Пароль верный")
```

Но в прошлом варианте, если бы у нас было несколько чисел в имени. Мы бы увидели столько же раз предупреждение.
Чтобы такого не было, мы можем использовать специальное слово `break` чтобы остановить цикл. И тогда мы получим предупреждение только один раз.

```python
# Вариатор имени

if __name__ == '__main__':

	name = "Den4i3s4"
	num = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

	for _item in num:
		if _item in name:
			print("Не корректные данные. В имени не должно быть чисел")
			break
	else:
		print("Пароль верный")
```

---

==Задача:== Давайте снова решим Задача из 3 темы, но теперь используя циклы.

- Создать `не изменяемый массив` на 8 элементов, любого типа, и подсчитать сумму всех элементов в массиве.
- Допустим вы разрабатываете форму регистрации на сайте. Сейчас вам нужно создать такой валидатор,
    который бы проверял то что в поле с именем нет чисел. (Запомнить это Задача)

> ```python
> a = (1, 2, 3, 4, 5)
> res = 0
> for _x in a:
> 	res += _x
> print(res)
> ```

> ```python
> for _x in NUM:
> 	if _x in name:
> 		print("False")
> 		break
>
> else:
> 	print("True")
> ```

---

### Стандартные итераторы

range(`<start>,<stop>,<steep>`) → `int`

```python
# Пример создания массива с псевдослучайными числами

N = 10
a = []
for i in range(1,N,1):
	a.append(1277 % i)
print(a)

#> [0, 1, 2, 1, 2, 5, 3, 5, 8]
```

enumerate(`<__iter__>`) → `tuple[int,obj]`

```python
# Нумерация фамилий

array_name = [
		"Иванов",
		"Петров",
		"Сидоров",
		"Веткин",
		]

for index, name in enumerate(array_name):
	print(index, name)

# 0 Иванов
# 1 Петров
# 2 Сидоров
# 3 Веткин
```

zip(`<arr_A>`,`<arr_B>`) → `tuple[obj,obj]`

```python
# Контактные даннык

array_name = [
		"Иванов",
		"Петров",
		"Сидоров",
		"Веткин",
		]

array_phone_number = [
		89291207106,
		89291045106,
		892923007106,
		892910074446,
		]

array_contact_details = {}
for name, number in zip(array_name, array_phone_number):
	array_contact_details[name] = number

print(array_contact_details)

#{'Иванов': 89291207106, 'Петров': 89291045106, 'Сидоров': 892923007106, 'Веткин': 892910074446}
```

---

==Задача:== Присоединение таблиц. Нужно доделать алгоритм приведенный ниже чтобы она вывела следующие.

- `(1, 'Товар_1', 3, 3, 'Описание_товара_1')`
- `(2, 'Товар_2', 2, 2, 'Описание_товара_2')`
- `(4, 'Товар_3', 4, 4, 'Описание_товара_3')`
- `(5, 'Товар_4', 1, 1, 'Описание_товара_4')`

```python
# Join Присоединение таблиц
if __name__ == '__main__':
	arr1 = [
			(1, "Товар_1", 3), # id, product_name, fk
			(2, "Товар_2", 2),
			(4, "Товар_3", 4),
			(5, "Товар_4", 1),
			]

	arr2 = [
			(1, "Описание_товара_4"), # id, product_description
			(2, "Описание_товара_2"),
			(3, "Описание_товара_1"),
			(4, "Описание_товара_3"),
			]

	for _x in arr1:
		for _y in arr2:
			...
```

---

==Задача:== Есть массив `a = [1,2,3,4,5,6,7,38,29,30]`, нам нужно обнулить все не четные числа в этом массиве.

- ![](_attachments/dcbdc36c516a322e4c34b9dad4ed5900.png)

---

Использование `continue`

```python
# Излишки товаров на складе

array_warehouse: dict[str, int] = {
		"Шкафы"   : 3,
		"Ковры"   : 5,
		"Телефоны": 10,
		"Кровати" : 7,
		}

surplus_goods: int = 0
for _name_item, _count in array_warehouse.items():
	if _count > 4:
		if _name_item == "Телефоны":
			continue
		surplus_goods += _count

print(surplus_goods)

#> 12
```

---

Использование `break`

```python
# Поиск сменщика

array = [
		[8, "Ваня", 8922307124, "vany@google.com"],
		[9, "Петя", 89293007124, "pety@google.com"],
		[11, "Олег", 892910074312, "oleg@google.com"],
		[12, "Сергей", 89292317124, "sergoi@google.com"],
		[16, "Катя", 892913107124, "katy@google.com"],
		[14, "Маша", 8929147124, "masha@google.com"],
		]

required_time = 11 # У кого начинаться смена 11 часов ?

people_work_shift:list = []
for _item in array:
	if _item[0] == required_time:
		people_work_shift = _item
		break
else:
	print("В это время не у кого нет смены")

print(people_work_shift)

#> [11, 'Олег', 892910074312, 'oleg@google.com']
```

`break` останавливает только внутренний цикл, и не влияет на выше стоящий

```python
for _x in range(10):
	for _i in range(2):
		if _x == 2:
			break

	print(_x, end=" ")

# 0 1 2 3 4 5 6 7 8 9
```

Как остановить главный цикл из вложенного

```python
for _x in range(10):
	try:
		for _i in range(2):
			if _x == 2:
				raise StopIteration
	except StopIteration:
		break
	print(_x, end=" ")

# 0 1
```

---

==Задача== Допустим мы пишем парсер для группы в ВК. Мы хотим обрабатывать только те записи, в которых
есть хештег `#python`, а те записи у которых не этого хештега, будем считать рекламой, и поэтому будем их прописать.

Допустим мы получили такие данные:

```python
a = ("Подробный туториал о том, как шаг за шагом создать сайт с бэкендом на Django, фронтендом на Vue и связкой между ними на GraphQL. Для всех любителей Python и современной веб-разработки. https://proglib.io/p/polnyy-fullstek-pishem-sayt-na-d.. #python #django #pirsipy",
"Фантастические миры ближе, чем кажется. Игры — отличный способ выразить свои чувства и мысли, объединив их в игровую концепцию. Начать путь в разработке игр вам поможет бесплатный онлайн-интенсив Skillbox, который пройдёт 22–24 июля в 21:00 по московскому времени: ✍ https://vk.cc/c40O7r В программе интенсива:",
"Учимся читать код, изучая стандартную библиотеку Python #python #pirsipy",
)

```

![](_attachments/27d5dc8a2ce6fa06996c01554aadaf07.png)

---

### `while`

Выполняться пока выражение верно.

```python
while <Выражение1 Выражение2 ... Выражение3>:
	...
```

Использование `while`

```python
# Нахождение НОД (Наибольшего общего делителя)

a = 50
b = 130

while a != 0 and b != 0:
	if a > b:
		a = a % b
	else:
		b = b % a

print(a + b)
```

![](_attachments/197226298aac788d6d59ef8227e94102.png)

---

==Задача:== Допустим мы делаем консольную форму для входа на `GitHab`.
В ней есть два вопроса `username`; `token` пользователя.
Нам нужно проверить что пользователь правильно ввел свой `username` и `token`.
У пользователя не ограничений на количество попыток входа.

```python
secret_user_name = "ivanov_vani"
secret_token = "ghp_pWJlre7ReLDpadasdQZasIdXasdaqSADUKasaY2s"
```

---

## Закрепление:

### !

==Задача:== Найти наименьшее число в массиве `array = [77, 10, 2, 233, 0, 99, 1]`

> ```python
> # Пример поиска минимума в массиве
> array = [77, 10, 2, 233, 0, 99, 1]
>
> last_num = array[0]  # 77
> for i in array:
> 	if i < last_num:
> 		last_num = i
> print(last_num)
>
> ```

# Тема 5.1 Строки. Основные операции со строками

## Теория:

![](_attachments/e8d98b4972e72996da3635ebfd222f69.png)

Строки в `Python` могут храниться в кодировке `utf-2` `utf-8` `utf-16`. Кодировка определяется
автоматически.

### Форматирование строк

```python
# Падеж для возроста
from typing import Union


def GetMaturityOld(age: Union[int, str]):
	age = str(age)

	if age in ["11", "12", "13", "14"]:
		return "лет"
	if age[-1] == '1':
		return 'год'
	elif age[-1] in '234':
		return "года"
	else:
		return "лет"


if __name__ == '__main__':
	first_name = "Denis"
	last_name = "Kustov"
	old = 21

	_tmp = f"Меня зовут {first_name} {last_name} мне {old} {GetMaturityOld(old)}"

	_tmp = "Меня зовут {} {} мне {} {}".format(first_name, last_name, old, GetMaturityOld(old))

	_tmp = "Меня зовут {fn} {ln} мне {old} {mt}".format(fn=first_name, ln=last_name, old=old, mt=GetMaturityOld(old))
	print(_tmp)

# Меня зовут Denis Kustov мне 21 год
```

### Основные операции со строками

| Команда                                                                        | Описание                                                                                   |
| ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------ |
| len(`<str>`)→`int`                                                             | Длинна итерируемого объекта (`__len__`)                                                    |
| str.find(`<ИскомоеСлово>, <start>, <end>`) → `int`                             | Поиск подстроки в строке. Возвращает номер первого вхождения или -1                        |
| str.refind(`<ИскомоеСлово>, <start>, <end>`) → `int`                           | Поиск подстроки в строке. Возвращает номер последнего вхождения или -1                     |
| str `*` `<3>` →`str`                                                           | Повторить строку                                                                           |
| str_A + str_B → `str`                                                          | Конкатенация                                                                               |
| str[`<Индекс>`] → `str`                                                        | Обращение по индексу                                                                       |
| str[`<start>:<stop>:<steep>`] → `str`                                          | Слайс (`__getitem__`)                                                                      |
| str.replace(`'<ИскатьЭто>', '<ЗаменитьНа>', <МаксимальноеЧислоЗамен>`) → `str` | Замена слов в строке, на шаблон                                                            |
| str.split(`'<РазделитьПоСимволу>'`) → `lsit`                                   | Разделяет строку по указанным символам                                                     |
| str.isdigit() → `bool`                                                         | Состоит ли вся строка из цифр                                                              |
| str.isalpha() →`bool`                                                          | Состоит ли вся строка из букв                                                              |
| "РазделительСимволом".join(`<List>`) → `str`                                   | Собрать строку из списка, через разделитель !(Все элементы массива должны быть типа `str`) |
| str.count(`<ИскомоеСлово>,<start>, <end>`)                                     | Подсчитать количество слов в строке                                                        |
| str.strip(`<СимволКоторыйУдалить>`)                                            | Обрезать стоку, по указанному символы, в начале и в конце                                  |
| str.translate(`<map_dict>`)                                                    | Заменить символы в сроке по правилам `<map_dict>`                                          |

[Все методы строк](https://pythonworld.ru/tipy-dannyx-v-python/stroki-funkcii-i-metody-strok.html)

---

Поиск подстроки в строке `find()`

```python
string = "Меня зовут Denis Kustov мне 21 год"
print(string.find("21", 0, 10)) # -1

print(string.find("21", 0))  # 28
```

---

Замена слова по шаблону `replace()`

```python
string = "Меня зовут Denis Kustov мне 21 год"
print(string.replace("21 год", "22 года")) # Меня зовут Denis Kustov мне 22 года

string = "10+22+33+5-6*7"
print(string.replace("+", "-",2)) # 10-22-33+5-6*7
```

---

Использование `slice`

```python
# Обрезать время из лог файлов
if __name__ == '__main__':
	string = [
			"26.09:18:24 - info - Сообщение1",
			"26.09:18:26 - info - Сообщение2",
			"26.09:18:28 - info - Сообщение3",
			"26.09:18:30 - info - Сообщение4",
			"26.09:18:45 - info - Сообщение5",
			"26.09:18:55 - info - Сообщение6",
			"26.09:18:67 - info - Сообщение7",
			]
	for _item in string:
		print(_item[13:])

	"""
	 info - Сообщение1
	 info - Сообщение2
	 info - Сообщение3
	 info - Сообщение4
	 info - Сообщение5
	 info - Сообщение6
	 info - Сообщение7
	"""
```

---

==Задача:== Получить записи только с `debug`

```python
string = [
		"26.09:18:24 - info - Сообщение1",
		"26.09:18:26 - debug - Сообщение2",
		"26.09:18:28 - info - Сообщение3",
		"26.09:18:30 - info - Сообщение4",
		"26.09:18:45 - debug - Сообщение5",
		"26.09:18:55 - info - Сообщение6",
		"26.09:18:67 - debug - Сообщение7",
		]


"""

debug - Сообщение2
debug - Сообщение5
debug - Сообщение7

"""
```

> ```python
> for _x in string:
> 	if _x.find("debug") != -1:
> 		print(_x[14:])
> ```

---

==Задача:== Изменить строки с названием `debug` на `debug_database`

> ```python
> for _i, _x in enumerate(string):
> 	string[_i] = _x.replace("debug", "debug_database")
> ```

---

Использование `split()`

```python
string = "Меня зовут Denis Kustov мне 21 год"
print(string.split(" "))  # ['Меня', 'зовут', 'Denis', 'Kustov', 'мне', '21', 'год']

string = "  \t Меня зовут \nDenis Kustov мне 21 год  "
print(string.split(" "))  # ['', '', '\t', 'Меня', 'зовут', '\nDenis', 'Kustov', 'мне', '21', 'год', '', '']

string = "  \t Меня зовут \nDenis Kustov мне 21 год  "
print(string.split())  # ['Меня', 'зовут', 'Denis', 'Kustov', 'мне', '21', 'год']

string = "https://pythonz.net/references/named/str.split"
print(string.split("/")[2:])  # ['pythonz.net', 'references', 'named', 'str.split']
```

---

==Задача:== В Linux системах принято заменять пробелы в имени файлов, нижними подчеркиваниями `_`.
Допустим у нас есть 3 папки

- `Мои фотки`
- `Мои документы`
- `Конспеткы по Python`

Нужно заменить пробелы на `_`

---

Конвертируем данные для записи в cvs файл через `join()`

**Неправильно**

```python
if __name__ == '__main__':
	array_name = [
			[0, "Иванов", ],
			[1, "Петров", ],
			[2, "Сидоров", ],
			[3, "Веткин", ],
			]

	file = ""
	for item in array_name:
		file += ", ".join(item)  # TypeError: sequence item 0: expected str instance, int found
		file += '\n'

	print(file)
```

**Правильно**

```python
array_name = [
		[0, "Иванов", ],
		[1, "Петров", ],
		[2, "Сидоров", ],
		[3, "Веткин", ],
		]

file = ""
for item in array_name:
	item[0] = str(item[0]) #!

	file += ", ".join(item)
	file+='\n'

print(file)


# 0, Иванов
# 1, Петров
# 2, Сидоров
# 3, Веткин
```

---

==Задача:== Допустим у нас есть подписочный сервис. И мы хотим чтобы когда у нашего клиента оставалось менее
4 дней до окончания подписки, ему отправлялось сообщение о том что его подписка заканчивается.

```python
data_base  = [
		("Олег",10),
		("Светлана",3),
		("Джордж",5),
		("Инокентий",4),
		("Павел",20),
		]

"""
Здравствуйте Светлана, напоминаем что через 3 дня у вас закончится подписка
"""

```

> ```python
> for _x in data_base:
> 	if _x[1] < 4:
> 		print(f"Здравствуйте {_x[0]}, напоминаем что через {_x[1]} дня у вас закончится подписка")
> ```

---

Подсчитать все указанные слова в строке `count()`

```python

if __name__ == '__main__':
	string = """
Россия — священная наша держава,
Россия — любимая наша страна.
Могучая воля, великая слава —
Твоё достоянье на все времена!
"""
	print(string)
	print(string.count("Россия")) # 2

```

---

Обрезать указанные символы в строке, в начале, и в конце`strip()`

```python
name = "_Denis_1_"
print(name) # _Denis_1_
print(name.strip("_")) # Denis_1

```

Все символы `Ascii`

```python
import string

print(string.ascii_letters) # abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

print(string.ascii_lowercase) # abcdefghijklmnopqrstuvwxyz

print(string.ascii_uppercase) # ABCDEFGHIJKLMNOPQRSTUVWXYZ

print(string.digits) # 0123456789

print(string.punctuation) # !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
```

---

Транслятор строк. (Можно использовать для шифрования сообщений)

```python
if __name__ == '__main__':
	translate_map = {
			ord("h"): "*",
			ord("e"): "!",
			ord("l"): "-",
			ord("o"): ".",
			ord("w"): "(",
			ord("r"): "&",
			ord("d"): "@",
			ord(" "): "_",
			}

	string = "hello world".translate(translate_map)
	print(string) # *!--._(.&-@

```

## Закрепление

### !

> Разбираем задачи

Дана строка, проверить, что она является палиндромом

```python
def isPalindrome(palemorf):
	palemorf = ''.join(palemorf.split())
	# Используем встроенную функцию
	rev = ''.join(reversed(palemorf))

	# Проверяем строки на равенство
	return True if palemorf == rev else False


if __name__ == '__main__':
	_string = "лёша на полке клопа нашёл"
	ans = isPalindrome(_string)
	print(ans)

```

# Тема 5.2. Встроенные структуры данных

## Теория:

### tuple

#### Описание `tuple`

`tuple` - Стандартный неизменяемы массив для хранить данных.

---

Вы не можете изменять элементы в кортеже:

```python
>>> a = (1,2,3)
>>> a[0] = 10
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

Но вы можете изменить изменяемые объекты:

```python
>>> b = (1,[1,2,3],3)
>>> b[1]
[1, 2, 3]
>>> b[1].append(4)
>>> b
(1, [1, 2, 3, 4], 3)
```

Вы можем только получать данные из `tuple`

```python
if __name__ == '__main__':
	a = (1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 9)

	print(a[2:5])  # (3, 1, 2)
	print(a + a)  # (1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 9, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 9)
	print(a[3])  # 1
	print(a.count(3))  # 3
	print(len(a))  # 12

```

| Метод                              | Описание                    |
| ---------------------------------- | --------------------------- |
| tuple.[`<index>`]                  | Можно обращаться по индексу |
| tuple.[`<start>, <stop>, <steep>`] | Можно использовать слайсы   |

### list

#### Характеристика

`list` - Универсально хранилище для данных. Быстрый доступ по индексам.

---

- ![](_attachments/2eb88e58360304462f5536fca04da991.png)
- ![](_attachments/18636548f93b7600e295f3b61bee0df9.png)
- ![](_attachments/573087778bcba31353e6617568ffe1b0.png)
- ![](_attachments/84ea1b1f42267b472558c1b46b975c03.png)
- ![](_attachments/2f2fb5a06327afd2c5db51598107041a.png)

Удаляем с конца O(1)

```python
import time

if __name__ == "__main__":
	a = [x for x in range(0, 10_000_000)]

	print("Start")
	start = time.process_time()
	for _ in range(len(a)):
		a.pop()
	end = time.process_time()

	print(end - start) #0.7648182560000001 sec
```

Удаляем с начала O(n)

```python
import time

if __name__ == "__main__":
	a = [x for x in range(0, 100_000)]

	print("Start")
	start = time.process_time()
	for _ in range(len(a)):
		a.pop(0)
	end = time.process_time()

	print(end - start) #1.2337459240000002 sec
```

```python
import time

if __name__ == "__main__":
	a = [x for x in range(0, 500_000)]

	print("Start")
	start = time.process_time()
	for _ in range(len(a)):
		a.pop(0)
	end = time.process_time()

	print(end - start) #80.221463992 sec
```

![](_attachments/0cbc3192a2a595286fac9a10bf079f84.png)

Теперь вспомним про `.append()`

```python
import time

if __name__ == "__main__":
	a = []
	print("Start")
	start = time.process_time()
	for x in range(0, 500_000):
		a.append(x)
	end = time.process_time()

	print(end - start)  # 0.057108991 sec
```

И сравним его `.insert()`

```python
import time

if __name__ == "__main__":

	a = []
	print("Start")
	start = time.process_time()
	for x in range(0, 500_000):
		a.insert(0,x)
	end = time.process_time()

	print(end - start)  # 59.448281873000006 sec
```

---

Зато у `list` самый быстрый доступ к элементу по индексу

```python
import time
from collections import deque

if __name__ == "__main__":
	a = [x for x in range(0, 500_000)]

	print("Start")
	start = time.process_time()

	print(a[len(a) // 2])

	end = time.process_time()
	print(end - start)  # 0,0000000000000099 sec

```

Асимптотика

- Доступ к элементу О(1)
- Вставка | удаление в конец О(1 амортизированное)
- Вставка | удаление в начало О(n)

#### Api `list`

| Метод                                                     | Описание                                                                                                         |
| --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| list.append(`<ЧтоДобавить>`)                              | Добавляет элемент в конец списка                                                                                 |
| list.extend(`<NewList:list>`)                             | Расширяет список list, добавляя в конец все элементы списка L                                                    |
| list.insert(`<index>`, `<ЧтоДобавить>`)                   | Вставляет перед `<index>` значение `<ЧтоДобавить>`                                                               |
| list.remove(`<ЧтоУдалить>`)                               | Удаляет первый элемент в списке, имеющий значение `<ЧтоУдалить>`. ValueError, если такого элемента не существует |
| list.pop(`<index>`) -> `obj`                              | Удаляет элемент по индексу, и возвращает его. Если индекс не указан, удаляется последний элемент                 |
| list.index(`<ЧтоИскать>, <start:int> <end:int>`) -> `int` | Возвращает `<index>` первого элемента со значением `<ЧтоИскать>` (при этом поиск ведется от `start` до `end`)    |
| list.count(`<ЧтоИскать>`) -> `int`                        | Возвращает количество элементов со значением x                                                                   |
| list.sort(`[key=функция], reverse=False`) -> `list`       | Сортирует список на основе функции                                                                               |
| list.reverse()                                            | Разворачивает список                                                                                             |
| list.copy() ->`list`                                      | Поверхностная копия списка                                                                                       |
| list.clear()                                              | Очищает список                                                                                                   |
| list[`<index>`]                                           | Получить элемент по индексу                                                                                      |
| list[`<start>`:`stop`:`steep`]                            | Получить слайс                                                                                                   |

---

`.insert()`

```python
if __name__ == '__main__':
	a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 9]
	a.insert(1,"H")
	print(a) # [1, 'H', 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 9]
```

---

`.remove()`

```python
if __name__ == '__main__':
	a = ["Дом","Телевизор","Мост"]
	a.remove("Телевизор")
	print(a) # ['Дом', 'Мост']
```

---

`.pop()`

```python
if __name__ == '__main__':
	a = ["Дом","Телевизор","Мост"]
	a.pop()
	print(a)
```

```python
if __name__ == '__main__':
	a = ["Дом","Телевизор","Мост"]
	a.pop(0)
	print(a)
```

---

`.index()`

```python
if __name__ == '__main__':
	a = ["Дом","Телевизор","Мост"," Дом"]
	print(a.index("Телевизор")) # 1
	print(a.index("Дом")) # 0
```

---

==Задача:== Допустим у нас есть таблица `a` в которой хранится.

| Имя футбольной команды, | Количество победных матчей этой команды. |
| ----------------------- | ---------------------------------------- |
| Зенит                   | 5                                        |
| Динамо                  | 4                                        |
| Локомотив               | 2                                        |
| Краснодар               | 3                                        |
| Химки                   | 3                                        |

Нам нужно оставить в таблице `a` только те команды, которые набрали более 3 победных матча.

```python
if __name__ == "__main__":
	a = [
			("Зенит", 5), # Имя команды, количество побед
			("Динамо", 4),
			("Локомотив", 2),
			("Краснодар", 3),
			("Химки", 3),
			]

	"""
	a = [
		("Зенит", 5),
		("Динамо", 4),
	]
	"""
```

> ```python
> if __name__ == '__main__':
> 	a = [
> 			("Химки", 3),
> 			("Краснодар", 3),
> 			("Зенит", 5),  # Имя команды, количество побед
> 			("Динамо", 4),
> 			("Локомотив", 2),
> 			]
>
> 	_index = 0
> 	for _i in range(len(a)):
> 		print(_index)
> 		if a[_index][1] < 4:
> 			a.pop(_index)
> 		else:
> 			_index += 1
>
> 	print(a)
> ```

---

`.sort()`

![](_attachments/05fb5b7ecf63f383a416305309b13411.png)

![](_attachments/512929b4fdba176787d92692f7332496.png)

Простой пример использования сортировки. (`Timsort`)

````python
if __name__ == '__main__':
	a = [3, 4, 2, 56, 1, 23, 56]

	print(a) # [3, 4, 2, 56, 1, 23, 56]
	print(id(a)) # 1398227529376```python


	a.sort()

	print(a) # [1, 2, 3, 4, 23, 56, 56]
	print(id(a)) # 139822752937600

````

Как использовать ананимную функцию в сортировки

```python
if __name__ == '__main__':
	a = [
			("Зенит", 5), # Имя команды, количество побед
			("Динамо", 4),
			("Локомотив", 2),
			("Краснодар", 3),
			("Химки", 3),
			]

	b = a.sort(key=lambda k: k[1])

	print(a) # [('Локомотив', 2), ('Краснодар', 3), ('Химки', 3), ('Динамо', 4), ('Зенит', 5)]
```

Также мы можем использовать параметр `revers`

```python
if __name__ == '__main__':
	a = [
			("Зенит", 5), # Имя команды, количество побед
			("Динамо", 4),
			("Локомотив", 2),
			("Краснодар", 3),
			("Химки", 3),
			]

	b = a.sort(key=lambda k: k[1], reverse=True)

	print(a) # [('Зенит', 5), ('Динамо', 4), ('Краснодар', 3), ('Химки', 3), ('Локомотив', 2)]
```

---

==Задача:== Мы создали свой форум. В нем программисты могут выкладывать различие посты.
Нам нужно для главной ленты сайты, отсортировать посты по количеству посещений.

```python
if __name__ == '__main__':
	a = [
			("Советы по Python", {"viwe": 90, "like": 30}),  # Название публикации, кол. просмотров, кол. лайков
			("Советы по Java", {"viwe": 34, "like": 8}),
			("Уроки по django", {"viwe": 50, "like": 30}),
			("5 фактов по Python которые вы точно не знали", {"viwe": 120, "like": 42}),
			("Учим ИИ распознавать плохой и хороший код", {"viwe": 79, "like": 43}),
			]

	"""
	('5 фактов по Python которые вы точно не знали', 	{'viwe': 120, 'like': 42})
	('Советы по Python', 								{'viwe': 90, 'like': 30})
	('Учим ИИ распознавать плохой и хороший код', 		{'viwe': 79, 'like': 43})
	('Уроки по django', 								{'viwe': 50, 'like': 30})
	('Советы по Java', 									{'viwe': 34, 'like': 8})
	"""

```

> ```python
> a.sort(key=lambda k: k[1]["viwe"], reverse=True)
> ```

---

`.reverse()`

```python
if __name__ == '__main__':
	a = [1, 2, 3, 4, 5]
	print(a)  # [1, 2, 3, 4, 5]
	a.reverse()
	print(a)  # [5, 4, 3, 2, 1]
```

---

`.copy()`

```python
if __name__ == '__main__':

	a = [1, 2, 3, 1, ]
	print(id(a)) # 140292928608000

	b = a.copy()

	print(id(a)) # 140292928608000
	print(id(b)) # 140292928487232

	###

	b[0] = 'H'

	print(a) # [1, 2, 3, 1]
	print(b) # ['H', 2, 3, 1]


```

Пример объясняющий, что такое поверхностное копии

```python
# Пример поверхностной копии
if __name__ == '__main__':

	# Все ОК
	a = [1, 2, 3, ]

	b = a.copy()

	print(a)  # [1, 2, 3]

	a[1] = "H"

	print(a)  # [1, 'H', 3]
	print(b)  # [1, 2, 3]




	# Проблема (нужно использовать глубокую копию)
	a = [1, [1,2,3], 3,]

	b = a.copy()

	print(a)        # [1, [1, 2, 3], 3]

	a[1][0] = "H"

	print(a)        # [1, ['H', 2, 3], 3]
	print(b)        # [1, ['H', 2, 3], 3]

```

Пример глубокого копии

```python
# Пример глубокого копии
import copy

if __name__ == '__main__':
	a = [1, [1,2,3], 3,]
	b = copy.deepcopy(a)

	print(a) # [1, [1, 2, 3], 3]

	a[1][0] = "H"

	print(a) # [1, ["H", 2, 3], 3]
	print(b) # [1, [1, 2, 3], 3]

```

---

`.clear()`

```python
if __name__ == '__main__':
	a = [1, 2, 3]
	print(a) # [1, 2, 3]
	a.clear()
	print(a) # []
```

---

Многомерные массивы

```python
if __name__ == '__main__':
	arr = [
			[1, 2, 3],
			[4, 5, 6],
			[7, 8, 9],
			]

	for _x in arr:
		for _y in _x:
			print(_y, end=", ")

# 1, 2, 3, 4, 5, 6, 7, 8, 9,
```

---

==Задача:== У нас есть двумерный массив.

```python
arr = [
		[1, 2, 3],
		[4, 1, 6],
		[7, 8, 1],
		]
```

Придумать алгоритм который бы дал следующий результат.

```python
arr = [
		[1, 8, 7],
		[6, 1, 4],
		[3, 2, 1],
		]
```

> ```python
> arr.reverse()
> for _x in arr:
> 	_x.reverse()
> ```

---

#### Генераторы списков (list comprehension)

Способ через `.append()`

```python
import time

if __name__ == "__main__":

    print("Start")
    start = time.process_time()
    a = []
    for x in range(0, 500_000):
        a.append(x)
    end = time.process_time()
    print(end - start)  # 0.058658954
```

Способ через генератор списка

```python
import time

if __name__ == "__main__":
	print("Start")
	start = time.process_time()
	a = [x for x in range(0, 500_000)]
	end = time.process_time()
	print(end - start)  # 0.03210756599999999

```

Мы видим что генераторы списка работают быстрее метода `append`, это происходит из-за того, что
генератор списка не обращается к глобальной области видимости. Плюс они более красивые, а как гласит первый
пункт Python Zen "Красота имеет значение".

---

Правила использования Генераторы списков

```python
[<Значение_В_Список>  for <item> in <obj.__iter__>  <Выражение1 Выражение2 ... Выражение3>]
```

Пример создание массива из `range`

```python
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

arr = []
for _x in range(10):
	arr.append(_x)

# ======================

arr = [_x for _x in range(10)]

```

Пример использования условного оператора (Добавляем только четные числа)

```python
 # [0, 2, 4, 6, 8]
arr = []
for _x in range(10):
	if _x % 2 == 0:
		arr.append(_x)

# ======================

arr = [_x for _x in range(10) if _x % 2 == 0]
```

Пример использования нескольких условного оператора

```python
# [6, 8]

arr = []
for _x in range(10):
	if _x % 2 == 0 and _x > 5:
		arr.append(_x)

# ======================

arr = [_x for _x in range(10) if _x % 2 == 0 and _x > 5]
```

Пример создание нового массива на основе существующего, но с использованием **фильтров**.

```python
# ['Земля', 'Марс', 'Юпитер', 'Сатурн', 'Уран', 'Нептун']

name = [
		["Меркурий", 57_910_006],
		["Венера", 108_199_995],
		["Земля", 149_599_951],
		["Марс", 227_939_920],
		["Юпитер", 778_330_257],
		["Сатурн", 1_429_400_028],
		["Уран", 2_870_989_228],
		["Нептун", 4_504_299479],
		]

arr = []
for _name, _dist in name:
	if _dist > 108_299_995:
		arr.append(_name)

# ======================


arr = [_name for _name, _dist in name if _dist > 108_299_995]
```

---

==Задача:== Создать массив, и наполнить его десятью нечетными псевдослучайными числами, с помощью генератора **списка**.

> ```python
> arr = [(1227 * _x) % 100 for _x in range(10)]
> ```

---

#### Генератор выражений (generator expressions)

Правила использования Генераторы выражений

```python
(<Значение_В_Список>  for <item> in <obj.__iter__>  <Выражение1 Выражение2 ... Выражение3>)
```

Генератор выражений является ленивый. Это он работает только когда мы вызовем метод `__next__()`. Его можно представить как
формулу для действий, и она будет рассчитывать только когда мы об этом попросим.

```python
if __name__ == '__main__':
	a = (x for x in range(5))
	print(a)  # <generator object <genexpr> at 0x7f98f7ff0200>

	print(a.__next__())  # 0
	print(a.__next__())  # 1
	print(a.__next__())  # 2
	print(a.__next__())  # 3
	print(a.__next__())  # 4
	print(a.__next__())  # StopIteration
```

Пример использования в `for`

```python
if __name__ == '__main__':
	a = (x for x in range(5))
	for _x in a:
		print(_x) # 0 1 2 3 4
```

Пример как можно в одну сорочку перебрать весь генератор выражения. `list()`
(По сути когда мы используем генератор списка, мы используем генератор выражений, только полностью перебирая его.)

```python
if __name__ == '__main__':
	a = (x for x in range(5))

	print(list(a))  # [0, 1, 2, 3, 4]

	# ======================

	b = [x for x in range(5)]

	print(b)  # [0, 1, 2, 3, 4]
```

Мы можем не беспокоится о размерах генератора, потому что он просто формула.

```python
if __name__ == '__main__':
	a = (x for x in range(100_000_000) if x % 2)

	print(a.__next__()) # 1
	print(a.__next__()) # 3
	print(a.__next__()) # 5
	print(a.__next__()) # 7
```

Обратите внимание, мы получаем элемент когда условное выражения с право верно.
Только тогда и у нас возвращается `x`, а если выражение не верно то генератор выражений
переходит на новую итерацию.

```python
if __name__ == '__main__':
	a = (x for x in range(100_000_000) if x % 64 == 0)

	print(a.__next__()) # 0
	print(a.__next__()) # 64
	print(a.__next__()) # 128
	print(a.__next__()) # 192

```

---

Когда использовать Генератор списка, а когда Генератор выражений ?

Генератор списка:

- Если вам нужно получить все значения из генератора

Генератор выражений:

- Если вам нужно получить не все элементы, или вы вообще не знаете сколько вам нужно получить элементов.
- Можно использовать в качестве параметров для функции. (Например для конструктора генератора очереди)

---

==Задача:== Создать массив, и наполнить его десятью нечетными псевдослучайными числами, с помощью генератора **выражений**.

> ```python
> 	arr = ((1227 * _x) % 100 for _x in range(10))
> 	print(list(arr))
> ```

---

### deque

#### Характеристика

`deque` - Нужен при работе с потоками. А так же если вы часто вставляете или удаляете элементы.

---

![](_attachments/Pasted%20image%2020210930132646.png)

`deque` Очередь. Двусвязный список

---

Удаление с конца

```python
import time
from collections import deque

if __name__ == "__main__":
	a = deque(x for x in range(0, 500_000))

	print("Start")
	start = time.process_time()
	for _ in range(len(a)):
		a.pop()
	end = time.process_time()
	print(end - start) # 0.03558158800000001
```

Удаление с начала

```python
import time
from collections import deque

if __name__ == "__main__":
	a = deque(x for x in range(0, 500_000))

	print("Start")
	start = time.process_time()
	for _ in range(len(a)):
		a.popleft()
	end = time.process_time()
	print(end - start) # 0.036198921999999994
```

Добавление в конец

```python
import time
from collections import deque

if __name__ == "__main__":

	print("Start")
	start = time.process_time()

	a = deque()

	for x in range(0, 500_000):
		a.append(x)

	end = time.process_time()
	print(end - start)  # 0.05964816899999999

```

Добавление в начало

```python
import time
from collections import deque

if __name__ == "__main__":

	print("Start")
	start = time.process_time()

	a = deque()

	for x in range(0, 500_000):
		a.appendleft(x)

	end = time.process_time()
	print(end - start)  # 0.059555574

```

Доступ к элементу по середине

```python
import time
from collections import deque

if __name__ == "__main__":
	a = deque(x for x in range(0, 500_000))

	print("Start")
	start = time.process_time()

	print(a[len(a) // 2])

	end = time.process_time()
	print(end - start)  # 0.00016051300000000102

```

[Асимптотика](https://docs.python.org/3/library/queue.html)

- Доступ к элементу О(n)
- Вставка | удаление в конец О(1 амортизированное)
- Вставка | удаление в начало О(1)

#### Api `deque`

| Метод                                                 | Описание                                                                                                         |
| ----------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| .append(`<Данные>`)                                   | Добавить в конец                                                                                                 |
| .appendleft(`<Данные>`)                               | Добавить в начало                                                                                                |
| .copy()                                               | Поверхностная копия                                                                                              |
| .clear()                                              | Отчистить массив                                                                                                 |
| .count(`<ЭлементДляПодсчета>`) -> `int`               | Получить количество элементов                                                                                    |
| .extend(`obj.__iter__`)                               | Расширить массив в конец                                                                                         |
| .extendleft(`obj.__iter__`)                           | Расширить массив в начало                                                                                        |
| .index(`<ЧтоИскать>, <start:int> <end:int>`) -> `int` | Возвращает `<index>` первого элемента со значением `<ЧтоИскать>` (при этом поиск ведется от `start` до `end`)    |
| .insert(`<index>`, `<ЧтоДобавить>`)                   | Вставляет перед `<index>` значение `<ЧтоДобавить>`                                                               |
| .pop()                                                | Удалить элемент с конца                                                                                          |
| .popleft()                                            | Удалить элемент с начало                                                                                         |
| .remove(`<ЧтоУдалить>`)                               | Удаляет первый элемент в списке, имеющий значение `<ЧтоУдалить>`. ValueError, если такого элемента не существует |
| .reverse()                                            | Разворачивает список                                                                                             |
| **sorted**(`<deque>`)                                 | Сортировать                                                                                                      |
| deque_obj[`<index>`]                                  | Получить элемент по индексу                                                                                      |
| itertools.islice                                      | Получить слайс                                                                                                   |
| del deque_obj[`<index>`]                              | Удалить элемент по индексу                                                                                       |

---

`sorted()` Сортировка массива

```python
if __name__ == '__main__':
	a = deque(

			[(3, 1, 5, 6, 12),
			 (3, 3, 5, 6, 12),
			 (3, 2, 5, 6, 12),
			 (3, 4, 5, 6, 12),
			 (3, 5, 5, 6, 12), ]
			)

	print(sorted(a, key=lambda k: k[1]))

"""
[(3, 1, 5, 6, 12),
 (3, 2, 5, 6, 12),
 (3, 3, 5, 6, 12),
 (3, 4, 5, 6, 12),
 (3, 5, 5, 6, 12)]
 """
```

---

В `deque` нет стандартного метода получения слайса, но для этих целей можно использовать `itertools.islice`

Пример того что в `deque` нет метода для слайсов.

```python
from collections import deque
if __name__ == '__main__':
	a = deque(

			(3, 1, 5, 6, 12)

			)

	print(a[1])     # Все Ок
	print(a[1:3])  # TypeError: sequence index must be integer, not 'slice'
```

Пример того как можно получить слайс через `itertools.islice`

```python
import itertools
from collections import deque

if __name__ == '__main__':
	a = deque(

			(3, 1, 5, 6, 12)

			)

	print(a[1])  # Все Ок

	b = itertools.islice(a, 2, 4)  # Все Ок
	for x in b:
		print(x, end=" ")  # 5 6

```

---

Удаление элемента по индексу `del`

```python
from collections import deque

if __name__ == '__main__':
	a = deque(

			(3, 1, 5, 6, 12)

			)

	print(a) # deque([3, 1, 5, 6, 12])

	del a[1] # == a.__delitem__(1)

	print(a) # deque([3, 5, 6, 12])

```

#### Генераторы очереди

Такой же синтаксис, как и у генератора списка

```python
[<Значение_В_Список>  for <item> in <obj.__iter__>  <Выражение1 Выражение2 ... Выражение3>]
```

Только их нужно писать в `deque()` без квадратных скобок. (тогда это получится генератор выражений)

```python
from collections import deque

if __name__ == '__main__':
	a = [1, 2, 3, 4, 5, 6]

	b = deque(x for x in a)

	print(b)  # deque([1, 2, 3, 4, 5, 6])

```

---

==Задача:== Давайте вспомним как работает очередь.

У нас есть следующий массив

```python
[1, 2, 3, 4, 5, 6]
```

Нам нужно создать из него очередь. А так же нам нужно понять как поставить первый элемент из очереди, в конец, за одну инструкцию .

> ```python
> from collections import deque
>
> if __name__ == '__main__':
> 	b = deque([1, 2, 3, 4, 5, 6])
>
> 	print(b)
>
> 	b.append(b.popleft())
>
> 	print(b)
> ```

---

### dict

#### Характеристика

`dict` = Нужен для быстрого доступа к данным.

---

Поиск в Хеш таблице

```python
import time

if __name__ == "__main__":
	a = {x for x in range(0, 10_000_000)}

	print("Start")
	start = time.process_time()
	if 9_000_000 in a:
		print("Да")
	end = time.process_time()

	print(end - start) # 0,0000000000000068 sec
```

```python
import time

if __name__ == "__main__":
	a = [x for x in range(0, 10_000_000)]

	print("Start")
	start = time.process_time()
	if 9_000_000 in a:
		print("Да")
	end = time.process_time()

	print(end - start) # 0,09063348299999996 sec

```

```python
>>> 0.09063348299999996 / 0.0000000000000068
13328453382353
```

Поиск в хеш таблицы в 13328453382352(Тринадцать триллионов триста двадцать восемь миллиардов) раз быстрее чем в `list`

![](_attachments/Pasted%20image%2020210930143148.png)

- Доступ к элементу О(1)
- Вставка О(1 амортизированное)

[Перевод нано секунд в секнды](http://shpargalkablog.ru/2013/10/seconds-minutes-clock.html)

---

Как работает хеш-функция

Она работает благородя "кольцу" из дискретной математике.
Если мы попробуем взять модуль от любого числа, то он будет не превышать модуль от которого мы его взяли.
Диапазон всех возможных чисел будет от (`0 ... mod`)

```python
"""
		0 % 4 = 0
		1 % 4 = 1
		2 % 4 = 2
		3 % 4 = 3
		---------
		4 % 4 = 0
		5 % 4 = 1
		6 % 4 = 2
		7 % 4 = 3
		---------
		8 % 4 = 0
		9 % 4 = 1
		10 % 4 = 2
		11 % 4 = 3
		---------
		---------
		9996 % 4 = 0
		9997 % 4 = 1
		9998 % 4 = 2
		9999 % 4 =  3
		---------
		---------
"""
```

---

#### Api `dict`

| Метод                                                                     | Описане                                                                        |
| ------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| dict.get(`<key>,<ЧтоВернутьЕслиНету>`) -> `<val> OR <ЧтоВернутьЕслиНету>` | Возвращает значение ключа, но если его нет, возвращает `<ВернутьЕслиНету>`     |
| dict.items() -> `iter(k,v)`                                               | Возвращает итератор с ключом и значением                                       |
| dict.values() `iter(v)`                                                   | Возвращает итератор с значением                                                |
| dict.keys() ->`iter(k)`                                                   | Вернуть итератор только с ключами                                              |
| dict.copy() -> `dict`                                                     | Вернуть копию словаря                                                          |
| dict.clear()                                                              | Очищает словарь                                                                |
| dict.setdefault(`<key>,<ЗначПоУмолчанию>`) -> `<ЗначПоУмолчанию>`         | Добавить ключ и значение в словарь, **Только** если такого ключа нет в словаре |
| dict.update(`<new_dict>`)                                                 | Добавить в текущий словарь, `k,v` из другой словарь                            |
| dict.pop(`<key>,<ЧтоВернутьЕслиНету>`) -> `<val> OR <ЧтоВернутьЕслиНету>` | Удалить пару по ключу, если такого ключа нет то вернуть `<ЧтоВернутьЕслиНету>` |
| dict.popitem() -> `(<key>,<val>)`                                         | Возвещает последнюю пару из словаря, а потом удаляет её                        |

---

`.setdefault()`

```python
if __name__ == '__main__':
	a = {
			1: 2,
			2: 2,
			3: 2,
			4: 2,
			5: 2,
			6: 2,
			}
	print(a)
	print(a.setdefault(10, "По умолчанию 1"))
	print(a)  # {1: 2, 2: 2, 3: 2, 4: 2, 5: 2, 6: 2, 10: 'По умолчанию 1'}
	print(a.setdefault(10, "По умолчанию 2"))  # Значение не поменялось так как ключ с таким именем уже есть
	print(a)  # {1: 2, 2: 2, 3: 2, 4: 2, 5: 2, 6: 2, 10: 'По умолчанию 1'}

```

---

`.update()`

```python
if __name__ == '__main__':
	a = {
			1: 2,
			2: 2,
			3: 2,
			4: 2,
			5: 2,
			6: 2,
			}

	b = {
			10: 3,
			11: 3,
			12: 3,
			}

	print(a)

	a.update(b)

	print(a)

```

---

`.pop()`

```python
if __name__ == '__main__':
	a = {
			1: 2,
			2: 2,
			3: 2,
			4: 2,
			5: 2,
			6: 2,
			}

	b = {
			10: 3,
			11: 3,
			12: 3,
			}

	print(a)  # {1: 2, 2: 2, 3: 2, 4: 2, 5: 2, 6: 2}

	a.pop(4)

	print(a)  # {1: 2, 2: 2, 3: 2, 5: 2, 6: 2}

```

---

`.popitem()`

```python
if __name__ == '__main__':
	a = {
			1: 2,
			2: 2,
			3: 2,
			4: 2,
			5: 2,
			6: 2,
			}

	b = {
			10: 3,
			11: 3,
			12: 3,
			}

	print(a)  # {1: 2, 2: 2, 3: 2, 4: 2, 5: 2, 6: 2}

	a.popitem()
	a.popitem()

	print(a)  # {1: 2, 2: 2, 3: 2, 4: 2}

```

---

==Задача:== Мы решили запустить свой DNS сервер, и у нас есть два массива

```python
domen_name = [
		"vk.com", "google.com", "yandex.ru"
		]

id_adders = [
		"87.240.129.133", "172.217.22.14", "77.88.8.8",
		]
```

Нам нужно получить словарь в виде

```python
DNS = {
		"vk.com"    : "87.240.129.133",
		"google.com": "172.217.22.14",
		"yandex.ru" : "77.88.8.8",
		}
```

> ```python
> DNS = {}
> for _x, _y in zip(domen_name, id_adders):
> 	DNS[_x] = _y
> ```

---

==Задача:== Теперь нам нужно из словаря DNS

```python
DNS = {
		"vk.com"    : "87.240.129.133",
		"google.com": "172.217.22.14",
		"yandex.ru" : "77.88.8.8",
		}
```

Получить два массива с доменом и адресом

```python
domen_name = [
		"vk.com", "google.com", "yandex.ru"
		]

id_adders = [
		"87.240.129.133", "172.217.22.14", "77.88.8.8",
		]
```

> ```python
> for k, v in DNS.items():
> 	domen_name.append(k)
> 	id_adders.append(v)
>
> print(domen_name)
> print(id_adders)
> ```

---

#### TypedDict

`TypedDict` Нужен для удобного создания словарей.

```python
from typing import TypedDict


class Point2D(TypedDict):
	x: int
	y: int
	label: str


if __name__ == '__main__':
	a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}
	b = Point2D(x=1, y=2, label="good")

	print(a) # {'x': 1, 'y': 2, 'label': 'good'}
	print(b) # {'x': 1, 'y': 2, 'label': 'good'}

```

#### Генератор словаря (dictionary comprehension)

Такие же правила как у генератора списка, но теперь нужно указывать `<key>:<val>`, и помещать генератор в фигурные скобки `{}`

```python
domen_name = [
		"vk.com", "google.com", "yandex.ru"
		]

id_adders = [
		"87.240.129.133", "172.217.22.14", "77.88.8.8",
		]

DNS = {_k: _v for _k, _v in zip(domen_name, id_adders)}

print(DNS)
```

### set

#### Характеристика

`set` - Нужен если вам необходимо хранить уникальные значения.

---

Устроен так же как и `dict` только в нем могут храниться только уникальные ключи.

![](_attachments/Pasted%20image%2020210929220117.png)

- Доступ к элементу О(1)
- Вставка О(1 амортизированное)

#### Api `set`

| Метод                       | Описание                                                         |
| --------------------------- | ---------------------------------------------------------------- |
| set.add(`Значение`)         | Добавить значение в множество                                    |
| set.union(`<set>`) ->`set`  | Объединение нескольких множеств, вернуть новое множество         |
| `<x>`.update(`<set>`)       | Объединение в `x` множестве, нескольких множеств.                |
| set.copy() ->`set`          | Копировать множество                                             |
| `<x>`.difference(`<y>`)     | Возвращает множество элементов, которые есть в `х`, но нет в `y` |
| `<x>`.intersection(`<y>`)   | Возвращает множество, являющийся пересечением `x` и `y`          |
| `<x>`.isdisjoint(`<y>`)     | True, если `x` и `y` не имеют общих элементов                    |
| set.pop()                   | Возвращает последний элемент, а потом его удаляет.               |
| set.discard(`<ЧтоУдалить>`) | Удалить указанный элемент, если его нет, то игнорирует.          |
| set.remove(`<ЧтоУдалить>`)  | Удалить указанный элемент, если его нет, то вызывает ошибку      |
| set.clear()                 | Отчистить множество                                              |

---

`.difference()` Возвращает множество элементов, которые есть в `х`, но нет в `y`

```python
a = {1, 2, 3, 4, 5}
b = {2, 4, 5}

print(a.difference(b)) # {1,3}
```

![](_attachments/Pasted%20image%2020210930165326.png)

---

`.intersection()` Возвращает множество, являющийся пересечением `x` и `y`

```python
a = {1, 2, 3, 4, 5}
b = {2, 4, 5}

print(a.intersection(b)) # {2, 4, 5}
```

![](_attachments/Pasted%20image%2020210930164919.png)

---

`.isdisjoint()` True, если `x` и `y` не имеют общих элементов

```python
a = {1, 2, 3, 4, 5}
b = {2, 4, 5}

print(a.isdisjoint(b))  # {2, 4, 5}
```

---

Разница между `discard` и `remove`

```python
a = {1, 2, 3, 4, 5}
b = {2, 4, 5}

a.discard(23) # Все Ок
a.remove(23)  # KeyError: 23

print(a)
```

---

Поиск в множестве

```python
set_ = {1, 2, 3, 4, 5}
a = 5
if a in set_: # Нужно использовать такую конструкцию
	print(a)
```

---

==Задача:== У нас множество, котором хранятся пути, к используемым файлам. Нам нужно реализовать следующую логику.
Когда мы хотим добавить уже существующий путь в множество, мы должны получить оповещение "Внимание - такой путь {path} уже существует".
А если такого пути нет в множестве, то добавить.

```python
a = {
	"/dev/lightnvm/",
	"/dev/block/",
	"/dev/hugepages/",
}
```

> ```python
> if __name__ == '__main__':
>
> 	path_set = {
> 			"/dev/lightnvm/",
> 			"/dev/block/",
> 			"/dev/hugepages/",
> 			}
>
> 	new_path = "/dev/block/new"
> 	if new_path in path_set:
> 		print(f"Внимание - такой путь {new_path} уже существует")
> 	else:
> 		path_set.add(new_path)
>
> 	print(path_set)
> ```

---

#### Генератор множества (set comprehension)

Такой же синтаксис, как и у генератора списка. Но его нужно помещать в фигурные скобки `{}`

```python
{<Значение_В_Список>  for <item> in <obj.__iter__>  <Выражение1 Выражение2 ... Выражение3>}
```

```python
if __name__ == '__main__':
	path_list = [
			"/dev/lightnvm/",
			"/dev/block/",
			"/dev/hugepages/",
			]

	path_set = {_x for _x in path_list} # {'/dev/block/', '/dev/hugepages/', '/dev/lightnvm/'}

	print(path_set)
```

### namedtuple

#### Описание `namedtuple`

`namedtuple` - Нужен для понятного хранения неизменяемых данных.

---

`namedtuple` Именованный картеж.

```python
from typing import NamedTuple


class UserDataClass(NamedTuple):
	name: str
	email: str



if __name__ == '__main__':
	user = UserDataClass(name="Kosta", email="Kosta007@rambler.ru")
	print(user)  # UserDataClass(name='Kosta', email='Kosta007@rambler.ru')
	print(user.name)  # Kosta
	print(user.email)  # Kosta007@rambler.ru
```

Является неизменяемым типом. Может выступать в качестве ключа в словаре

```python
from typing import NamedTuple


class UserDataClass(NamedTuple):
	test_atr: str


if __name__ == '__main__':
	a = {
			UserDataClass("1"): 1,
			UserDataClass("2"): 1,
			UserDataClass("3"): 1,
			UserDataClass("4"): 1,
		}
	print(a)

	# {UserDataClass(test_atr='1'): 1, UserDataClass(test_atr='2'): 1, UserDataClass(test_atr='3'): 1, UserDataClass(test_atr='4'): 1}
```

Мы можем указывать значения по умолчанию

```python

from typing import NamedTuple


class UserDataClass(NamedTuple):
	name: str
	email: str
	friend: int = 0 # Значение по умолчанию


if __name__ == '__main__':
	user = UserDataClass(name="Kosta", email="Kosta007@rambler.ru")

	print(user)  		# UserDataClass(name='Kosta', email='Kosta007@rambler.ru', friend=0)
	print(user.name)  	# Kosta
	print(user.email)  	# Kosta007@rambler.ru
```

#### Api `namedtuple`

---

| Метод                                                 | Описане                                            |
| ----------------------------------------------------- | -------------------------------------------------- |
| namedtuple.`_asdict()` -> `dict`                      | Конвертировать в `dict`                            |
| namedtuple.`_replace`(`<name>=<val>`) -> `namedtuple` | Создать новый измененный объект                    |
| namedtuple.`_make`(`<List>`) -> `namedtuple`          | Создать `namedtuple` из `list`                     |
| namedtuple.`_fields` -> `tuple`                       | Получить имена полей из `namedtuple`               |
| namedtuple.`_field_defaults` -> `dict`                | Получить поля у которых есть значения по умолчанию |
| namedtuple.`<name_atr>`                               | Можно обращаться по имени атрибута                 |
| namedtuple.[`<index>`]                                | Можно обращаться по индексу                        |
| namedtuple.[`<start>, <stop>, <steep>`]               | Можно использовать слайсы                          |

---

`._asdict()` Конвертировать в `dict

```python
print(user._asdict()) # {'name': 'Kosta', 'email': 'Kosta007@rambler.ru'}
```

---

`._replace()` Создать новый измененный объект

```python
user2 =  user._replace(name='Valera')
print(user)		# UserDataClass(name='Kosta', email='Kosta007@rambler.ru')
print(user2)	# UserDataClass(name='Valera', email='Kosta007@rambler.ru')
```

---

`._make()` Создать `namedtuple` из `list`

```python
user3 = UserDataClass._make(['Nasta', "nasta@889"])
print(user3) 	# UserDataClass(name='Nasta', email='nasta@889')
```

---

`._fields` Получить имена полей из `namedtuple`

```python
print(user3._fields) # ('name', 'email')
```

---

`._field_defaults` Получить поля у которых есть значения по умолчанию

```python
from typing import NamedTuple


class UserDataClass(NamedTuple):
	name: str
	email: str
	status: int = None # Поле по умолчанию


if __name__ == '__main__':
	user = UserDataClass(name="Kosta", email="Kosta007@rambler.ru")
	print(user) # UserDataClass(name='Kosta', email='Kosta007@rambler.ru', status=None)
	print(user._field_defaults) # {'status': None}

```

---

Создать `namedtuple` из словоря

```python
from typing import NamedTuple


class UserDataClass(NamedTuple):
	name: str
	email: str
	status: int = None


if __name__ == '__main__':
	user = UserDataClass(**{'name': "Kosta", 'email': "Kosta007@rambler.ru"}) # Использовать ** для `dict`
	print(user) # UserDataClass(name='Kosta', email='Kosta007@rambler.ru', status=None)
	print(user._field_defaults) # {'status': None}

```

---

==Задача== Создать `namedtuple` с именем `Book`. Он должен иметь атрибуты: `author`, `book_name`, `public_year`.
После этого нужно создать3 объекта `Book` и поместить их в `list`.

```python
"Пушкин",  "Капитанская дочка", 1883,
"Тургенев", "Отцы и дети", 1862
"Шопенгауэр", "Афоризмы житейской мудрости", 1851
```

> ```python
> from pprint import pprint
> from typing import NamedTuple
>
>
> class Book(NamedTuple):
> 	author: str
> 	book_name: str
> 	public_year: int = 0
>
>
> if __name__ == '__main__':
> 	bk1 = Book("Пушкин", "Капитанская дочка", 1883)
> 	bk2 = Book("Тургенев", "Отцы и дети", 1862)
> 	bk3 = Book("Шопенгауэр", "Афоризмы житейской мудрости", 1851)
>
> 	book_list = [bk1, bk2, bk3]
>
> 	pprint(book_list)
>
> ```

---

### array

#### Характеристика

`array`- Эффективные массивы числовых значений. Концепция так же как у`list`, но при этом он в 10 раз меньше потребляет памяти.

```python
import array

from collections import deque

import numpy as np
from pympler.asizeof import asizeof

if __name__ == '__main__':
   a = [x for x in range(900)]

   arr1 = array.array('i', a)
   arr2 = a
   arr3 = tuple(a)
   arr4 = np.array([a])
   arr5 = deque(a)

   print("array\t", asizeof(arr1))
   print("numpy\t", asizeof(arr4))
   print("deque\t", asizeof(arr5))
   print("tuple\t", asizeof(arr3))
   print("list\t",  asizeof(arr2))
```

```cmd
array	 3664
numpy	 7336
deque	 8016
tuple	 36032
list	 36624
```

#### Api `array`

| Код типа | Тип в C            | Тип в python      | Минимальный размер в байтах |
| -------- | ------------------ | ----------------- | --------------------------- |
| 'b'      | signed char        | int               | 1                           |
| 'B'      | unsigned char      | int               | 1                           |
| 'u'      | wchar_t            | Unicode character | 2                           |
| 'h'      | signed short       | int               | 2                           |
| 'H'      | unsigned short     | int               | 2                           |
| 'i'      | signed int         | int               | 2                           |
| 'I'      | unsigned int       | int               | 2                           |
| 'l'      | signed long        | int               | 4                           |
| 'L'      | unsigned long      | int               | 4                           |
| 'q'      | signed long long   | int               | 8                           |
| 'Q'      | unsigned long long | int               | 8                           |
| 'f'      | float              | float             | 4                           |
| 'd'      | double             | float             | 8                           |

---

| Метод                                    | Описане                                 |
| ---------------------------------------- | --------------------------------------- |
| array.append(`<Значение>`)               | Добавить в конец                        |
| array.count(`<ЧтоПодсчитывать`) -> `int` | Количество вхождения элемента в массиве |
| array.extend(`<obj.__iter__>`)           | Расширить массив итерируемым объектом   |
| array.revers()                           | Развернуть массив                       |
| array.remove(`<ЧтоУдалять>`)             | Удалить элемент из массива              |
| array.pop()                              | Удалить элемент с конца                 |
| array.insert(`<index>,<ЧтоВставить>`)    | Вставить элемент по индексу             |
| array.fromlist(`<list_obj>`)             | Расширить массив из `list`              |
| array.fromunicode(`"<str_obj>""`)        | расширить массив из `str`               |
| ---                                      | ---                                     |
| array.tofile(`<ОбъектФайл>`)             | Записать данные в файл                  |
| array.tounicode()                        | Конвертировать в `str`                  |
| array.tolist()                           | Конвертировать в `list`                 |
| array.tobytes()                          | Конвертировать в байты                  |
| ---                                      | ---                                     |
| array.typecode                           | Получить кодовый символ                 |
| array.itemsize                           | Размер одного элемента (в байтах)       |

---

Пример создания `array`

```python
from array import array

if __name__ == '__main__':
	arr = array('u')

	for _x in "hello_world":
		arr.append(_x)

	print(arr)  # array('u', 'hello_world')

```

### Enum

Перечисление

```python
from enum import Enum

class Weapon(Enum):
      SWORD = 1
	 BOW = 2
	 DAGGER = 3
	 CLUB = 4


if __name__ == '__main__':

   weapon = Weapon.SWORD
   print(weapon)
   print(weapon.name)
   print(weapon.value)

   print(Weapon['SWORD'])
   print(Weapon(1))
```

## Закрепление:

### !

==Задача== Вспомнить какие типы есть в `Python`

Обобщеный тест

```python
----------------------------------------
Тест потребления памяти у массивов 1000:

      	asizeof	getsizeof
struct	 4040 	 4033			(сериализованные данные)
array 	 4064 	 4064
numpy 	 8136 	 8120
deque 	 8544 	 8544
tuple 	 40032 	 8040
list  	 40848 	 8856
set   	 64976 	 32984
----------------------------------------
----------------------------------------
Тест поиска элемента в массиве 999090:

dict  	4170	ns		(Зависит от случая, может быть быстрее set)
set  	1396	ns 		(Зависит от случая, может быть быстрее dict)
tuple	803727	ns
list	801763	ns
deque	902227	ns
numpy	1210239	ns
array	1411818	ns
----------------------------------------
----------------------------------------
Тест потребления памяти у классов:

          	asizeof	getsizeof
__slots__ 	 184 	 64
NamedTuple	 192 	 72
namedtuple	 192 	 72
tuple     	 192 	 72
__dict__  	 496 	 48
----------------------------------------
```

# Тема 6 Свои функции

## Теория:

### Роль функции в программировании

1.  Сокращение кода Код, который повторяется можно перенести в функцию и использовать её тогда, когда нужно выполнить код, который находится внутри этой функции.
2.  Логическое разделение программы Мы можем выделить определённое сложное действие (например перемножение матриц) в отдельную функцию, чтобы оно не мешалось в коде, даже если используем её один раз за всё время выполнения программы.

### Синтаксис функций

Правила создания функций

```python
def <Name>():

```

Функция может принимать неограниченное количество аргументов

```python
def <Name>(arg1, arg2):

```

Функция может возвращать значения. (Результат)

```python
def <Name>(a, b):
	return a+b
```

---

==Задача==

Напишите функцию, которая суммирует три числа.

> ```python
> def avg(a, b, c):
> 	return (a + b + c) / 3
>
>
> if __name__ == '__main__':
> 	print(avg(1, 2, 3))
>
> ```

---

Аргументы функция могут иметь значения по умолчанию. Оно подставиться если мы не передали аргументов

```python
def avg(a,b,c = 10):
	return (a + b + c) / 3

if __name__ == '__main__':
	print(avg(1, 2)) #4.333333333333333

```

А если мы передали аргументы то значение по умолчанию не подставится.

```python
def avg(a,b,c):
	return (a + b + c) / 3

if __name__ == '__main__':
	print(avg(1, 2, 4)) #2.3333333333333335

```

Мы можем также передавать аргументы по имени.

```python
def avg(a, b, c=10):
	return (a + b + c) / 3


if __name__ == '__main__':
	print(avg(a=1, b=2))  # 4.333333333333333

```

---

Мы можем установить передачу только именованных аргументов `*`

Будет ошибка, так как мы не передали именованные аргументы

```python
def avg(a, *, b, c):
	return (a + b + c) / 3


if __name__ == '__main__':
	print(avg(1, 2, 4))  # TypeError: avg() takes 1 positional argument but 3 were given

```

А в этом случае все будет работать.

```python
def avg(a, *, b, c):
   return (a + b + c) / 3


if __name__ == '__main__':
   print(avg(1, b=2, c=4))  # 4.333333333333333
```

---

Мы можем так же установить передачу только позиционных аргументы `/`.

Будет ошибка, так как мы не передали позиционные аргументы

```python
def avg(a, b, /, c):
	return (a + b + c) / 3


if __name__ == '__main__':
	print(avg(1, b=2, c=4))  # TypeError: avg() got some positional-only arguments passed as keyword arguments: 'b'

```

А в этом случае все будет работать.

```python
def avg(a, b, /, c):
	return (a + b + c) / 3


if __name__ == '__main__':
	print(avg(1, 2, 4))  # TypeError: avg() got some positional-only arguments passed as keyword arguments: 'b'

```

---

Мы можем передавать аргументы в функцию через раскрытие словаря `**dict`

```python
def avg(a, b, c):
	return (a + b + c) / 3


if __name__ == '__main__':
	d = {"a": 1, "b": 3, "c": 5}
	print(avg(**d)) # !
```

---

==Задача==

Напишите функцию, которая считает минимальную длину слова в строке.

> ```python
> def length(s):
> 	min =  len(s.split()[0])
>
> 	for _x in s.split():
> 		if len(_x) < min:
> 			min = len(_x)
> 	return max
>
>
> if __name__ == '__main__':
> 	print(length("hel llddol ll"))
> ```

---

### Область видимости

При передаче переменных, в качестве аргументов для функции. Данные **не** копируются

```python
def test4(a):
	print("test4\t", id(a))


def test3(a):
	print("test3\t", id(a))
	test4(a)


def test2(a):
	print("test2\t", id(a))
	a = a.copy() # !!!!
	test3(a)


def test1(a):
	print("test1\t", id(a))
	# a = ["1", "2"]
	test2(a)


if __name__ == '__main__':
	a = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, ]
	print("main\t", id(a))
	test1(a)
	print("main\t", id(a))

# main	 140303703459648
# test1	 140303703459648
# test2	 140303703459648
# test3	 140303703322432 # !
# test4	 140303703322432 # !
# main	 140303703459648
```

---

Глобальная область видимости. Использовать функцию `globals()`

```python
from pprint import pprint

test_name = True

if __name__ == '__main__':
	pprint(globals())

"""
{'__annotations__': {},
 '__builtins__': <module 'builtins' (built-in)>,
 '__cached__': None,
 '__doc__': None,
 '__file__': '/home/denis/PycharmProjects/consgui/test2.py',
 '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x7f3eca07cfd0>,
 '__name__': '__main__',
 '__package__': None,
 '__spec__': None,
 'pprint': <function pprint at 0x7f3ec9f31310>,
 'test_name': True}
"""
```

Локальная область видимости. Использовать функцию `locals()`

```python
from pprint import pprint

test_name = True


def test_fun():
	test_name2 = True
	pprint(locals())  # {'test_name2': True}
	pprint(globals())  # { ..., 'test_name': True}


if __name__ == '__main__':
	test_fun()
	pprint(locals())  # { ..., 'test_name': True}
	pprint(globals())  # { ..., 'test_name': True}
	print(locals() == globals())  # True

```

Мы можем читать глобальные значения из функций,

```python
from pprint import pprint

test_name = True


def test_fun():
	test_name2 = True

	print(test_name) # Все Ок



if __name__ == '__main__':
	test_fun()
```

Но не можем изменять глобальные значения.

```python
from pprint import pprint

test_name = True


def test_fun():
	test_name2 = True

	print(test_name) # UnboundLocalError: local variable 'test_name' referenced before assignment
	test_name = False


if __name__ == '__main__':
	test_fun()
```

---

Для того чтобы можно было изменять глобальное значение из функций. Нужно использовать оператор `global`

```python
test_name = True


def test_fun():
	global test_name

	print(test_name)  # True
	test_name = False


if __name__ == '__main__':

	print(test_name)  # True

	test_fun()

	print(test_name)  # False

```

---

В `Python` есть замыкание функций.
Это значит что мы создать функцию в функции. В замкнутых функциях у
нас есть доступ к чтению переменных которые находятся в выше стоящих функции.

```python
def counter():
	num = 0

	def incrementer():
		return num

	return incrementer()


if __name__ == '__main__':
	print(counter())

```

Но если мы также попробуем изменить данные, вне нашей видимости, мы получим ошибку.

```python
def co в unter():
	num = 0

	def incrementer():
		num += 1 # UnboundLocalError: local variable 'num' referenced before assignment
		return num

	return incrementer()


if __name__ == '__main__':
	print(counter())

```

Если мы хотим изменять данные из вложенных функций, нужно использовать оператор `nonlocal`

```python
def counter():
	num = 0

	def incrementer():
		nonlocal num
		num += 1 # Все Ок
		return num

	return incrementer()


if __name__ == '__main__':
	print(counter())

```

Так же во вложенной функции мы можем обращаться к глобально области видимости.

```python
test_name = True


def counter():
	num = 0

	def incrementer():
		global test_name
		print(test_name)
		return num

	return incrementer()


if __name__ == '__main__':
	print(counter())

```

---

### Передача изменяемых параметров

Стоит помнить о том что в `Python` есть изменяемы типы данных. И если мы изменим такие данные в функции, то они отразятся на данные вне функции.

Пример того как это можно использовать.

```python
import random
from typing import List


def get_random_voting(all_voices: List[int], is_get_random=True) -> int:
	if is_get_random:
		res = random.randint(0, all_voices[0])
		all_voices[0] = all_voices[0] - res
		return res
	else:
		return all_voices[0]


if __name__ == '__main__':
	all_voices = [100]

	print(get_random_voting(all_voices))
	print(get_random_voting(all_voices))
	print(get_random_voting(all_voices))
	print(get_random_voting(all_voices, is_get_random=True))
	print(all_voices)
```

### Рекурсия

Во многих языках программирования существует возможность, когда функция вызывает сама себя, это и называется рекурсия.

![](_attachments/Pasted%20image%2020211001183259.png)

```python
def factorial_recursive(n):
    if n == 1:
        return n
    else:
        return n*factorial_recursive(n-1)
```

Что нужно знать про рекурсию:

- Она устроенна по типу стека.
- В рекурсивной функции должно быть условие остановки.
- Любую рекурсивную функцию можно переписать без рекурсии.
- Не используйте рекурсию потому что она медленнее работает. И имеет лимит на 3000 вызова, и если превысить этот лимит у нас возникнет исключение.

```python
def factorial(n):
    res = 1
    for i in range(1, n + 1):
        res *= i
    return res
```

### Анонимные функции

Синтаксис

```python
lambda [аргументы]: [выражение]
```

---

Особенности:

Можно присвоить к переменной.

```python
a = lambda _a, _b: _a + _b

print(a(2, 8))
print(a(3, 8))
print(a(8, 8))
```

Можно установить в качестве значения для словаря.

```python
if __name__ == '__main__':
	math = {
			"sum" : lambda _a, _b: _a + _b,
			"diff": lambda _a, _b: _a - _b,
			"mul" : lambda _a, _b: _a * _b,
			}

	request = "mul"

	res = math.get(request, None)

	if res:
		print(res(2, 8))

```

Можно обращаться к переменным из глобальной области видимости.

```python
test_name = "test_name!"

if __name__ == '__main__':
	a = lambda : test_name

	print(a()) № test_name!

```

Из анонимной функции можно вызвать другие функции.

```python
def sum(a, b):
	return a + b


if __name__ == '__main__':
	a = lambda _a, _b: sum(_a, _b)

	print(a(3, 6))
```

---

Так же мы можем передавать функцию в качестве аргумента.

```python
from typing import Callable


def calc(a, b, fun: Callable[[int, int], int]):
   return fun(a, b)


def sum(a: int, b: int) -> int:
   return a + b


def mul(a: str, b: int) -> int:
   return int(a) + b


if __name__ == '__main__':
   print(calc(3, 6, mul))
```

Для правильной аннотации типа функции нужно использовать `Callable`

```python
Callable[ [<ТипАргумента1, ТипАргумента2, ... >], <ReturnType> ]
```

### Функции генераторы

Функции кроме `return` могут возвращать `yield`. В этом случае функция будет являться генератором.

```python
# Пример firewall

def firewall(arr_connect: list):
	for _item in arr_connect:
		if _item[0:3] == "222":
			yield _item


if __name__ == '__main__':
	arr = [
			"222.222.233.101",
			"322.232.233.101",
			"522.422.233.101",
			"222.522.233.101",
			]

	a = firewall(arr)


	for _x in firewall(arr):
	   print(_x)

	# 222.222.233.101
	# 222.522.233.101
```

### Декораторы функций

Декораторы нужны для расширения возможностей функций. Декоратор это функция которая принимает в качестве первого аргумента другую функцию

Например, декоратор который засекает время выполнения функции

```python
import time


def execute_time(fun):
	def wrapper(*arg, **kwargs):
		start = time.process_time()

		res = fun(*arg, **kwargs)

		end = time.process_time()

		print(start - end)

		return res

	return wrapper


@execute_time
def create_list(len_.: int) -> list:
	return [_x for _x in range(len_)]


if __name__ == '__main__':
	arr = create_list(100)
	print(arr)

```

Декоратор, который проверяет что пользователь авторизован, иначе не покажет пользователь не сможет попасть на сраницу.

```python
from typing import NamedTuple


def is_login(fun):
	def wrapper(*arg, **kwargs):
		db_hash = {
				"199.991.001.989": "df1sdq123daQ3123das"
				}
		if db_hash.get(arg[0].ip_adress, False) == arg[0].hash_:
			return fun(*arg, **kwargs)
		else:
			return "error 405"

	return wrapper


@is_login
def profile(request):
	return "<h1>Профиль<\h1>"


class User(NamedTuple):
	ip_adress: str
	hash_: str


if __name__ == '__main__':
	user = User(ip_adress="199.991.001.989", hash_="df1sdq123daQ3123das")

	print(profile(user))

```

Декоратор может принимать аргументы.

```python
from typing import NamedTuple

db_hash = {
		"199.991.001.989": "df1sdq123daQ3123das"
		}


def is_login(db_hash):
	def wrapper(fun):
		def decorated_function(*arg, **kwargs):

			if db_hash.get(arg[0].ip_adress, False) == arg[0].hash_:
				return fun(*arg, **kwargs)
			else:
				return "error 405"

		return decorated_function

	return wrapper


@is_login(db_hash)
def profile(request):
	return "<h1>Профиль<\h1>"


class User(NamedTuple):
	ip_adress: str
	hash_: str


if __name__ == '__main__':
	user = User(ip_adress="199.991.001.989", hash_="df1sdq123daQ3123das")

	print(profile(user))

```

### Аннотация типов

[Документация](https://docs.python.org/3/library/typing.html)

| Название | Описание                                     |
| -------- | -------------------------------------------- |
| Any      | Любой тип                                    |
| Union    | Переменная может принимать несколько типов   |
| Callable | Анатация для функции                         |
| Optional | Переменная может быть None                   |
| Final    | Указывает что нельзя изменять эту переменную |

Callable

```python
Callable[ [<ТипАргумента1, ТипАргумента2, ... >], <ReturnType> ]
```

Union

```python
Union[ Type1, Type2, Type3  ]

```

Optional

```python
Optional[ Type1  ] == Union[ Type1, None]
```

Final

```python
a:Final = [1,2,3]

a  = 0 # Будет предупреждение
```

## Закрепление:

### !

==Задача:== Создать функцию, которая приметает в качестве аргумента список, удаляет все нечетные значения из него, и возвращает его обратно.

# Тема 7 Стандартные функции

## Теория:

### Общие функции

`abs(<num>)` Возвращает абсолютное значение числа.

```python
abs(-5.6)
>> 5.6
```

`max(:__iter__)` Максимальное значение в списке

```python
max([3,4,1,88])
>> 88
```

`min(:__iter__)`Минимальное значение в списке

```python
min([3,4,1,88])
>> 1
```

`round(:float)` Округлить

```python
a = 1.5132
c = round(a)
print(c)
```

`sum(:__iter__)` Суммирует значение в списке

```python
sum([3,4,1,88])
>> 96
```

---

`id(:obj)` Возвращает идентификатор объекта.

```python
a = 10
b = 10

id(a) == id(b)

>> True
```

`dir(:obj)` Получить список всех методов и атрибутов объекта

```python
from pprint import pprint


class TestClass:
	test_name = True


if __name__ == '__main__':
	pprint(dir(TestClass))

```

`type(:obj)` Узнать тип объекта

```python
a = 101

type(a) == int
```

`isinstance(:obj)` Рекурсивная проверка типа, с учетом наследования классов.

```python
if __name__ == '__main__':
	print(type(False) == int) 		# False
	print(isinstance(False, int)) 	# True
```

---

`hasattr(:obj, <"ИмяАтрибута">)` Проверить существования атрибута. Если его нет, то возвращает `False`

```python
class TestClass:
	test_name = True


if __name__ == '__main__':
	print(hasattr(TestClass, "test_name")) # True

```

`getattr(:obj, <"ИмяАтрибута">)` Проверить существования атрибута. Если его нет, то вызвает исключение `AttributeError`

```python
class TestClass:
	test_name = True


if __name__ == '__main__':
	print(getattr(TestClass, "test_na1me")) # AttributeError: type object 'TestClass' has no attribute 'test_na1me'
```

### itertools

`chain` Поочередно итерируются по всем указанным массивам.

```python
from itertools import chain

if  __name__ == '__main__':

    a = [1, 2, 3]
    b = [4, 5, 6]
    c = [7, 8, 9]

    for x in chain(a, b, c):
        print(x, end=" ")

>>> 1 2 3 4 5 6 7 8 9
```

`cycle` Бесконечная итерация по массиву

```python
import time
from itertools import cycle

if __name__ == '__main__':

    a = [1, 2, 3]
    for x in cycle(a):
        print(x, end='\n')
        time.sleep(0.1)

>>> 1 2 3 1 2 3 1 2 3 1 2 3 1 2  ...
```

`islice` Создать срез без копирования массива

```python
from itertools import islice

if __name__ == '__main__':
    a = [1, 2, 3, 4, 5, 6]
    b = islice(a, 2, 5)
    for i, x in enumerate(b):
        print(f"{id(x)} - {id(a[i + 2])}")

```

`takewhile` Выполняет итерации, пока функция возвращает ==True==

```python
from itertools import takewhile


def test_fun(var):
    if var % 3:
        return True
    return False


if __name__ == '__main__':
    a = [1, 2, 3, 4, 5, 6]
    for x in takewhile(test_fun, a):
        print(x)

>>> 1 2
```

`dropwhile` Начинает возвращать элементы только когда функция впервые раз вернет ==False==

```python
from itertools import dropwhile


def test_fun(var):
    if var % 3:
        return True
    return False


if __name__ == '__main__':
    a = [1, 2, 3, 4, 5, 6]
    for x in dropwhile(test_fun, a):
        print(x)

```

### os

| Функция                                    | Описание                                                 | Аналог в ОС |
| ------------------------------------------ | -------------------------------------------------------- | ----------- |
| os.listdir(`path="."`)                     | Список файлов в директории                               | `ls`        |
| os.mkdir(`path`)                           | Создать директорию. Если директория существует `OSError` | `mkdir`     |
| os.makedirs(`path1/path2/path3`)           | Создать несколько вложенных папок                        |             |
| os.getcwd()                                | Текущая рабочая директория                               | `pwd`       |
| os.chdir(`path`)                           | Сменить текущую директорию                               | `cd`        |
| os.remove(`path`)                          | Удалить файл                                             | `rm`        |
| os.rename(`ПрошлоеИмя,НовоеИмя`)           | Переименовать файл                                       | `rename`    |
| os.replace(`path,new_path`)                | Переместить файл                                         | `mov`       |
| os.rmdir(`"folder`")                       | Удалить папку                                            | `rm -d`     |
| os.removedirs(`"nested1/nested2/nested3"`) | Удалить вложенные папки                                  | `rm -r`     |
| os.environ[]                               | Работа с переменными окружения                           |             |
| os.startfile(`path`)                       | Запустить файл в стандартной программе                   |             |
| os.system(`<command>`)                     | Испольник каманду                                        | `<command>` |
|                                            |                                                          |             |

Посмотреть переменные окружения ОС

```python
import os
if __name__ == '__main__':
	for _x in os.environ.items():
		print(_x)
```

Добавить свои переменные окружения

```python
import os

if __name__ == '__main__':
	os.environ["Любое Имя"] = "Любая Строка" # !
	for _x in os.environ.items():
		print(_x)

```

---

| Функция                              | Описание                                        |
| ------------------------------------ | ----------------------------------------------- |
| os.path.basename(path) ->`str`       | Получить только имя файла                       |
| os.path.dirname(path) ->`str`        | Получить только путь к файлу                    |
| os.path.isdir(path) ->`bool`         | Проверить существование папок в указанной пути  |
| os.path.isfile(path) ->`bool`        | Проверить существование файлов в указанной пути |
| os.path.exists(path) ->`bool`        | Проверить существования файла                   |
| os.path.join(path1,path2) -> `str`   | Соединятет пути                                 |
| os.path.split(path1,path2) ->`tuple` | Разеденить путь                                 |

`os.path.basename()`Получить только имя файла

```python
import os

os.path.basename(r'C:\Python27\Tools\pynche\ChipViewer.py')
# ChipViewer.py
```

`os.path.dirname()`Получить только путь к файлу

```python
import os

print( os.path.dirname(r'C:\Python27\Tools\pynche\ChipViewer.py') )
# C:\\Python27\\Tools\\pynche
```

`os.path.join()` Соединятет пути

```python
import os

print( os.path.join(r'C:\Python27\Tools\pynche', 'ChipViewer.py') )
# C:\\Python27\\Tools\\pynche\\ChipViewer.py
```

`os.path.split(path1,path2)`` Разеденить путь

```python
import os

print( os.path.split(r'C:\Python27\Tools\pynche\ChipViewer.py') )
# ('C:\\Python27\\Tools\\pynche', 'ChipViewer.py')
```

### time

| Функция                   | Описание                                               |
| ------------------------- | ------------------------------------------------------ |
| time.time() -> `float`    | UTC Секунды с 1970 года                                |
| time.ctime(`UTC`) ->`str` | Получить местное время                                 |
| time.sleep(`Секунд`)      | Приостановить программу на указанное количество секунд |

```python
import time

if __name__ == '__main__':
	a = time.time()

	print(a) # 1633115152.5488627
	print(time.ctime(a)) # Fri Oct  1 22:05:52 2021

```

[Другие функции](https://pythonru.com/osnovy/modul-time-v-python)

### sys

| Функция                 | Описание                                                                 |
| ----------------------- | ------------------------------------------------------------------------ |
| sys.argv                | Возвращает аргументы командной строки                                    |
| sys.path                | Возвращает все пути для поиска модулей Python                            |
| sys.version             | Этот метод показывает версию интерпретатора Python                       |
| sys.exit                | Метод exit выходит из программы Python или завершает конкретный процесс. |
| sys.platform            | Информация об операционной системе.                                      |
| sys.getsizeof(`<:obj>`) | Возвращает размер объекта (в байтах)                                     |
| sys.executable          | путь к интерпретатору Python                                             |

---

`sys.argv`

```python
import sys
if __name__ == '__main__':
	print(sys.argv)

```

```bush
(venv) [denis@denis-prog consgui]$ python test2.py -q -d --help
['test2.py', '-q', '-d', '--help']
```

---

`sys.path`

```python
import sys
from pprint import pprint

if __name__ == '__main__':
	pprint(sys.path)

"""
['/home/denis/PycharmProjects/consgui',
 '/home/denis/PycharmProjects/consgui',
 '/home/denis/Applications/pycharm-2020.1.1/plugins/python/helpers/pycharm_display',
 '/usr/lib/python39.zip',
 '/usr/lib/python3.9',
 '/usr/lib/python3.9/lib-dynload',
 '/home/denis/PycharmProjects/consgui/venv/lib/python3.9/site-packages',
 '/home/denis/Applications/pycharm-2020.1.1/plugins/python/helpers/pycharm_matplotlib_backend']

"""

```

### random

| Функция                                     | Описание                                                                                 |
| ------------------------------------------- | ---------------------------------------------------------------------------------------- |
| random.seed(:int)                           | Инициализация генератора случайных чисел. Если X не указан, используется системное время |
| random.getrandbits(:int) -> `int`           | Возвращает N случайных бит                                                               |
| random.randint(`A, B`) ->`int`              | Случайное число от A до B                                                                |
| random.choice(`__iter__`)->`obj`            | Случайный элемент непустой последовательности                                            |
| random.shuffle(`__iter__`)                  | перемешивает последовательность                                                          |
| random.random() -> `float`                  | случайное число от 0 до 1                                                                |
| random.uniform(A, B) ->`flaot`              | Случайное число от A до B                                                                |
| random.sample(`__iter__,<СколькоПолучить>`) | Возвращает список из псевдослучайных элементов, указанной длины                          |

`random.getrandbits()`

```python
import random
if __name__ == '__main__':
	pprint(random.getrandbits(8)) # 158
```

`random.randint()`

```pyth
on
import random
if __name__ == '__main__':
	print(random.randrange(0,100))
```

`random.choice()`

```python
import random

if __name__ == '__main__':
	a = ["- возвращает", "Случайны", "элемент", "из", "итерируемого объекта"]
	print(random.choice(a))

```

`random.shuffle()`

```python
import random

if __name__ == '__main__':
	a = ["- возвращает", "Случайны", "элемент", "из", "итерируемого объекта"]
	random.shuffle(a)
	print(a)  # ['из', 'Случайны', '- возвращает', 'элемент', 'итерируемого объекта']

```

`random.sample()`

```python
random.sample([0, 1, 2, 3, 4, 5, 6], 3)
>>> [6,5,4]
```

### datetime

| Функция          | Описание               |                            |
| ---------------- | ---------------------- | -------------------------- |
| datetime.now()   | Полная текущая дата    | 2020-11-14 15:43:32.249588 |
| datetime.today() | Текущий год день месяц | 2020-11-14                 |

```python
import datetime

if __name__ == '__main__':
	dt_now = datetime.datetime.now()
	print(dt_now) 			# 2021-10-01 23:39:44.327147

	print(dt_now.year)  	# 2021
	print(dt_now.month)  	# 10
	print(dt_now.day)  		# 5
	print(dt_now.hour)  	# 12
	print(dt_now.second)  	# 10
```

### functools

Кеш для функции `@lru_cache(maxsize=<Максимальное_Количество_Записей>)`

```python
from functools import lru_cache


@lru_cache(maxsize=30)
def test_fun(a, b, c):
	return a + b + c


if __name__ == '__main__':

	for x in range(1000):
		x = x % 10
		test_fun(1, x, 1)

	print(test_fun.cache_info())

	"""
	.cache_info() Информация о функции
		CacheInfo(hits=2, misses=1, maxsize=3, currsize=1)
		- hits = Сколько значений взято из кеша
		- misses = Сколько значений взяты НЕ из кеша
		- maxsize = Максимальный количество значений в кеше
		- currsize = Сколько уникальных значений в кеше

	.cache_clear() Отчистить кеш функции
	"""

```

---

Когда выпишите свои декораторы хорошим тоном считаться использовать `@wraps(<Функция>)`. Так как он не изменяет документацию у функций.
А если вы используете несколько декораторов как например в `Flask`, то там нужно обязательно использовать `@wraps(<Функция>)` так как он
правильно копирует значения в ниже стоящие декораторы.

`@wraps(func)`

```python
# Оберточная функция

def another_function(func):
	"""
	Функция которая принимает другую функцию
	"""

	def wrapper():
		"""
		Оберточная функция
		"""
		val = "The result of %s is %s" % (func(), eval(func()))
		return val

	return wrapper


@another_function
def a_function():
	"""Обычная функция"""
	return "1+1"


if __name__ == "__main__":
	# a_function()
	print(a_function.__name__)	# wrapper
	print(a_function.__doc__)	# Оберточная функция

```

```python
# Обычная функция
from functools import wraps


def another_function(func):
	"""
	Функция которая принимает другую функцию
	"""

	@wraps(func) # !!
	def wrapper():
		"""
		Оберточная функция
		"""
		val = "The result of %s is %s" % (func(), eval(func()))
		return val

	return wrapper


@another_function
def a_function():
	"""Обычная функция"""
	return "1+1"


if __name__ == "__main__":
	# a_function()
	print(a_function.__name__)	# a_function
	print(a_function.__doc__) 	# Обычная функция

```

## Закрепление:

### !

> Разбираем программу.

Подобрать пин-код

```python
# Брутфорс
import string
from random import *

PASSWORD = "1010"

if __name__ == '__main__':

	guess = "" # Переменная для сравнения с паролем
	letters = string.digits # Дата сет с числами для брутфорса
	_max_index = len(letters) - 1 # Ограничение для индекса  `randint`
	_index = 0 # Для статистики
	while guess != PASSWORD:
		guess = ""
		for letter in PASSWORD:
			guess_letter = letters[randint(0, _max_index)]
			guess = f"{guess_letter}{guess}"

		_index += 1
		print(f"{_index}: {guess}")

	print(f"Password = {guess}")
```

# Тема 8. Ввод - вывод, файловый ввод вывод.

## Теория:

### Ввод - вывод

- input(`<"Текст_в_консоль"="">`) → `str`
- print(`<"Текст_в_консоль"="">, *args, sep=' ', end='\n', file=None`) вызывает `__str__`

Пример пин-код

```python
# Пример пин-код
pin_cod_db = 6628 # 2209

pin_cod_user = int(input("Введите пин-код: "))

if 3*pin_cod_user+1 == pin_cod_db:
	print("Пик-код верный")
else:
	print("Пик-код не верный")
```

### Файловый ввод вывод

| Флаг | Описание                                            |
| ---- | --------------------------------------------------- |
| r    | Чтение                                              |
| w    | Запись, Если файл не существует, то он будет создан |
| a    | Дозаписать в конец файла                            |
| +    | Чтение и запись                                     |
| rb   | Чтение двоичны файлов                               |
| wb   | Запись в двоичный файл                              |
| ab   | Дозаписать в конец двоичного файла                  |

Сохранить настройки в файл

```python
# Сохранить в файл настройки
if __name__ == '__main__':
    with open('text1', "w") as MyFile:
        print("Green", file=MyFile) # Вызывает метод `MyFile.write("Green")`

    with open('text1', "r") as MyFile:
        color = MyFile.read()
        print(color) # Green
```

Зачем нужно закрывать файлы

```python
if __name__ == '__main__':
	MyFile2 = open('text1', "w")
	print("Black", file=MyFile2)

	# MyFile2.close() #!

	MyFile1 = open('text1', "r")
	print(MyFile1.read()) # None
```

```python
if __name__ == '__main__':
	MyFile2 = open('text1', "w")
	print("Black", file=MyFile2)

	MyFile2.close()

	MyFile1 = open('text1', "r")
	print(MyFile1.read()) # Black
```

---

Как устроен `with`

```python
class controlled_execution:
	def __enter__(self):
		self.file = []
		print(f"__enter__ {self.file}")
		return self

	def write(self, text: str):
		print("write", end=" :\t")
		self.file = text
		print(f"Привет {self.file}. Данные записаны")

	def __exit__(self, type, value, traceback):
		print(f"__exit__ :\t{'Файл закрыт'}")


if __name__ == '__main__':
	with controlled_execution() as thing:
		thing.write("Denis")
		raise StopIteration #!
		print(f'thing.file == {thing.file}')
```

[Пример сохранения геометрии и положения окна](https://github.com/denisxab/console_debugger/blob/master/gui/tk_terminal.py)

---

| Функция                      | Описание                          | Условие |
| ---------------------------- | --------------------------------- | ------- |
| .read() -> `str`             | Прочитать полностью файл          | r       |
| .readlines() ->`str`         | Построчный итератор               | r       |
| .seek(`<Место_в_файле:int>`) | Переместиться в указанную позицию | r       |
| .write(`"<Текст>"`)          | Записать данные в файл            | w / a   |
| .writelines(`"<Текст>"`)     | Записать построчно                | w / a   |

> `text1` Пример файла
>
> ```bush
> Black1
> Black2
> Black3
> Black4
> Black5
> Black6
> Black7
> ```

`.read()` Пример как прочитатьвесь файл

```python
if __name__ == '__main__':
	with open("text1", 'r') as _f:
		res = _f.read()
	print(res)

# Black1
# Black2
# Black3
# Black4
# Black5
# Black6
# Black7
```

`read(СколькоСимволов:int)` Как прочитать только несколько символов

```python
if __name__ == '__main__':
	with open("text1", 'r') as _f:
		res = _f.read(16)
	print(res)

# Black1
# Black2
# Bl
```

Пример как прочитать построчно файл

```python
if __name__ == '__main__':
	with open("text1", 'r') as _f:
		for _x in _f:
			print(f": {_x}", end="")

# : Black1
# : Black2
# : Black3
# : Black4
# : Black5
# : Black6
# : Black7
```

Или используя итератор `.readlines()`

```python
if __name__ == '__main__':
	with open("text1", 'r') as _f:
		for _x in _f.readlines():
			print(f": {_x}", end="")

# : Black1
# : Black2
# : Black3
# : Black4
# : Black5
# : Black6
# : Black7
```

Так же можно читать по одной строке

```python
if __name__ == '__main__':
	with open("text1", 'r') as _f:
		print(f"1 {_f.readline()}")
		print(f"2 {_f.readline()}")
		print(f"3 {_f.readline()}")

# 1 Black1
# 2 Black2
# 3 Black3
```

---

Зачем нужен `.seek()` ?

```python
if __name__ == '__main__':
	with open("text1", 'r') as _f:
		print(f"{_f.read()}") # seek == END
		print(f"{_f.read()}") # None
```

Пример использование `.seek()`

```python
if __name__ == '__main__':
	with open("text1", 'r') as _f:
		print(f"{_f.read()}")  # seek == END
		_f.seek(0)             # seek == Start
		print(f"{_f.read()}")  # Мы можем заново прочитать файл с начало
```

---

==Задача:== Создать свой зашифрованный токен, и сохранить его в файл

> ```python
> # Создать свой зашифрованный токен, и сохранить его в файл
> if __name__ == '__main__':
> 	token = 12345
> 	_secret_token = token * 3 + 5
> 	with open("text1", "w") as f:
> 		print(_secret_token, file=f)
>
> 	with open("text1", "r") as f:
> 		fr = f.read()
> 		print(fr)
> ```

---

## Закрепление:

### !

==Задача== Нужно сохранить в файл цвет и размер виджетов. А потом прочитать этот файл и записать данные в `dict`

```python
{
	"main_windows_bg": ("red","800x600"),
	"box_menu_fg": ("blue","400x300"),
}
```

> ```python
> if __name__ == '__main__':
> 	a = {
> 			"main_windows_bg": ("red", "800x600"),
> 			"box_menu_fg"    : ("blue", "400x300"),
> 			}
>
> 	with open("setting", 'w') as _f:
> 		for _k, _v in a.items():
> 			_f.writelines(f"{_k},{_v[0]},{_v[1]}\n")
>
> 	res = {}
> 	with open("setting", 'r') as _f:
> 		for _x in _f.readlines():
> 			_k, _v1, _v2 = _x.strip('\n').split(",")
> 			res[_k] = (_v1, _v2)
>
> 	print(res)
> 	print(f"{res == a}")
> ```

# Тема 9 Модули и Виртуальное окружение

## Теория:

### Как импортировать модули

Есть два способа

`import <module>`

```python
import sys

if __name__ == '__main__':
	print(f"{sys.path}")
```

`from <module> import <Переменная/функция/Класс>` Но в этом случае мы копируем (Переменную/Функцию/Класс)

```python
from sys import path

if __name__ == '__main__':
	print(f"{path}")
	print(sys) # NameError: name 'sys' is not defined
```

Вы можете импортировать так, но это нарушает `PEP 8`

```python
from sys import *

if __name__ == '__main__':
	print(f"{path}")
```

### Как ипортировать свой файл

Это очень просто. Если ваш файл находится на одном и том же уровне, то вы можете импортировать его по имени файла(без префикса `.py`)

> Структура проект

- testapp
    - main.py
    - model.py

`main.py`

```python
import model
```

или

`model.py`

```python
import main
```

---

Если вы попробуете из `main.py` импортировать (Переменную/Функцию/Класс) из файла `model.py` ,
который в свою очередь импортирует (Переменную/Функцию/Класс) из `main.py` то у вас будет ошибка. (Кольцевой импорт)

`main.py`

```python
from model import TEST_VAR_MODEL # ImportError: cannot import name 'TEST_VAR_MODEL' from partially initialized module 'model'

TEST_VAR_MAIN = True
if __name__ == '__main__':
	print(TEST_VAR_MODEL)

```

`model.py`

```python
from main import TEST_VAR_MAIN # ImportError: cannot import name 'TEST_VAR_MAIN' from partially initialized module 'main'


TEST_VAR_MODEL = True
if __name__ == '__main__':
   print(TEST_VAR_MAIN)
```

---

Чтобы решить эту проблему используйте

1. 3 файл
2. Импортируйте файл в локальную область видимости

    `main.py`

    ```python
    def init():
    	from model import TEST_VAR_MODEL
    	print(TEST_VAR_MODEL)


    TEST_VAR_MAIN = True
    if __name__ == '__main__':
    	init()

    ```

    `model.py`

    ```python
    def init():
    	from main import TEST_VAR_MAIN
    	print(TEST_VAR_MAIN)


    TEST_VAR_MODEL = True
    if __name__ == '__main__':
    	init()

    ```

### Как устроенно импортирование модулей

`Python` ищет модули в `sys,path`

```python
import sys
from pprint import pprint

if __name__ == '__main__':
	pprint(sys.path)
```

Мы можем как добавлять, так и удалять пути к модулям. Причем `Python` будет искать модули от начала до конца списка,
поэтом если вы импортирует модуль с одним и тем же именем, убедитесь в правильном приоритете путей в `sys.path`.

```python
 import sys
from pprint import pprint

if __name__ == '__main__':
	pprint(sys.path)

	sys.path.append("/home/denis/.config/JetBrains/PyCharm2020.1/scratches/scratch.py")

	pprint(sys.path)
```

---

> Структура проект

- consgui
    - folder
        - urllib.py
    - test2.py

Если мы добавили наш модуль в конце, то `Python` найдет первым стандартный модуль `urllib`

```python
import sys
from pprint import pprint


sys.path.append("./test")

pprint(sys.path)
import urllib

if __name__ == '__main__':
	print(urllib) # `<module 'urllib' from '/usr/lib/python3.9/urllib/__init__.py'>`

```

Если мы добавили наш модуль в начало, то `Python` найдет первым наш модул

```python
import sys
from pprint import pprint

sys.path.insert(0, "./test")


pprint(sys.path)
import urllib

if __name__ == '__main__':
	print(urllib) # <module 'urllib' from '/home/denis/PycharmProjects/consgui/folder/urllib.py'>

```

---

> Структура проект

- consgui

    - folder1
        - file_gui.py
    - folder2
        - file_model.py
    - main.py

`main.py` Когда мы ищем модули в глубину у нас нет проблем.

```python
from folder1 import file_gui
from folder2 import file_model

if __name__ == '__main__':
	print(f"{file_gui.TEST_VAR}")
	print(f"{file_model.TEST_VAR}")

```

![](_attachments/Pasted%20image%2020211002152552.png)

---

`folder1/file_gui.py` Но у нас появятся проблемы если мы захотим найти модуль в высоту. С первого взгляда если мы запустим нашу программу через `PyCharm`
то у нас не возникнет проблем.

```python
import main

if __name__ == '__main__':
	print(main.TEST_VAR)
	print(main)
```

![](_attachments/Pasted%20image%2020211002152713.png)

Но если мы запустим этот файл чрез консоль у нас возникнет исключение.

```bush
(venv) [denis@denis-prog folder1]$ ls
file_gui.py  __init__.py  __pycache__

(venv) [denis@denis-prog folder1]$ python file_gui.py
Traceback (most recent call last):
  File "/home/denis/PycharmProjects/consgui/folder1/file_gui.py", line 1, in <module>
    import main
ModuleNotFoundError: No module named 'main'
```

---

Давайте разберемся почему это так происходит. Выведем `sys.path`

Если запустить это файл через `PyCharm` то `sys.path` будет иметь путь к корню проекта`/home/denis/PycharmProjects/consgui`

```python
import sys
from pprint import pprint

if __name__ == '__main__':
	pprint(sys.path)
```

А если запустить файл через консоль, тот `sys.path` не будет знать о корне проекта, и, следовательно, не будет знать путь в высоту.

---

Чтобы решить проблему поиска модулей в высоту, нужно всегда добавлять корень проекта в `sys.path`.

```python
import sys
from os.path import dirname


def root_path(slice_end: int = 0, add_path: str = ""):
	"""
	Внимание!!! Путь отображается от места где находится сам файл `path_helper.py`

	Обрезает относительный путь, и может добавлять к нему другой путь:
	:param slice_end: Срез с конца
	:param add_path: Добавить путь
	:return:
	"""
	p = dirname(__file__).replace("\\", "/").split("/")
	if slice_end:
		p = p[:slice_end]
	if add_path:
		p.append(add_path.replace("\\", "/"))
	return "/".join(p)


sys.path.append(root_path(-1)) # !

import main

if __name__ == '__main__':
	print(main.TEST_VAR)
```

Чтобы лишний раз не добавлять корневой путь, можно использовать функцию `add_sys_path_if_not`

```python
import sys
from os.path import dirname
from typing import List


def root_path(slice_end: int = 0, add_path: str = ""):
	"""
	Внимание!!! Путь отображается от места где находится сам файл

	Обрезает относительный путь, и может добавлять к нему другой путь:
	:param slice_end: Срез с конца
	:param add_path: Добавить путь
	:return:
	"""
	p = dirname(__file__).replace("\\", "/").split("/")
	if slice_end:
		p = p[:slice_end]
	if add_path:
		p.append(add_path.replace("\\", "/"))
	return "/".join(p)


def add_sys_path_if_not(add_path: str, sys_path: List[str]):
	"""
	Добавить путь если его нет
	:param add_path:
	:param sys_path:
	:return:
	"""
	if add_path not in sys_path:
		sys_path.append(add_path)


add_sys_path_if_not(root_path(-1), sys.path) # !

import main

if __name__ == '__main__':
	print(main.TEST_VAR)

```

### Зачем нужен `__init__.py`?

Если НЕ использовать `__init__.py`

`main.py`

```python
from folder1 import file_gui

if __name__ == '__main__':
	print("main.py")
```

`folder1/file_gui.py`

```python
print("file_gui.py")
from folder2 import file_model
```

`folder2/file_model.py`

```python
print("file_model.py")
```

Вывод

```bush
file_gui.py
file_model.py
main.py
```

---

Если использовать `__init__.py`

`main.py`

```python
from folder1 import file_gui

if __name__ == '__main__':
	print("main.py")
```

`folder1/__init__.py`

```python
print("__init__.file_gui.py")
```

`folder1/file_gui.py`

```python
print("file_gui.py")
from folder2 import file_model
```

`folder2/__init__.py`

```python
print("__init__.file_model.py")
```

`folder2/file_model.py`

```python
print("file_model.py")
```

Вывод

```bush
__init__.file_gui.py
file_gui.py
__init__.file_model.py
file_model.py
main.py
```

---

А вот что будет если мы запустим файл `folder1/file_gui.py`. (Сработает только `__init__.py` у модуля который мы импортируем)

Вывод

```bush
file_gui.py
__init__.file_model.py
file_model.py
```

---

А что будет если мы импортируем два разных модуля, которые находятся в одной папке. (`__init__.py` сработает только один раз)

Вывод

```bush
file_gui.py
__init__.file_model.py
file_model.py
file_model2.py
```

---

Итог:

- `__init__.py` Вызваться автоматически при импорте любого `файла.py` из папки.
- Папка, которая имеет `__init__.py` называется модулем (пакетом).
- `__init__.py` Вызваться только один раз.

### `__all__`

Если вам нужно ограничить импорт (Переменной/Функции/Класса) нужно использовать `__all__`.
Обратите внимание это работает только когда, используется `from <module> import *`

---

Разрешаем импорт в `__all__`

`main.py`

```python
from model import *


TEST_VAR_MAIN = "TEST_VAR_MAIN"
if __name__ == '__main__':
	print(TEST_VAR_MODEL) #  TEST_VAR_MODEL

```

`model.py`

```python
__all__ = ["TEST_VAR_MODEL"]

TEST_VAR_MODEL = "TEST_VAR_MODEL"
if __name__ == '__main__':
	print()
```

---

Запрещаем импорт в `__all__`

`main.py`

```python
from model import * # AttributeError: module 'model' has no attribute ''


TEST_VAR_MAIN = "TEST_VAR_MAIN"
if __name__ == '__main__':
	print(TEST_VAR_MODEL)

```

`model.py`

```python
__all__ = [""]

TEST_VAR_MODEL = "TEST_VAR_MODEL"
if __name__ == '__main__':
	print()

```

---

А если мы импортируем на прямую (Переменной/Функции/Класса) , то у нас нет ограничений.

`main.py`

```python
from model import TEST_VAR_MODEL


TEST_VAR_MAIN = "TEST_VAR_MAIN"
if __name__ == '__main__':
   print(TEST_VAR_MODEL)

```

`model.py`

```python
__all__ = [""]

TEST_VAR_MODEL = "TEST_VAR_MODEL"
if __name__ == '__main__':
	print()

```

### Как настроить виртуальное окружение через терминал

Установка ВО

| Linux                             | Windows |
| --------------------------------- | ------- |
| `sudo apt install python3.8-venv` |         |

Создать виртуальное окружение

| Linux                    | Windows                  |
| ------------------------ | ------------------------ |
| `python -m venv <ИмяВО>` | `python -m venv <ИмяВО>` |

Активировать

| Linux                    | Windows                      |
| ------------------------ | ---------------------------- |
| `. <ИмяВО>/bin/activate` | `.\<ИмяВО>\Scripts\activate` |

Выйти из ВО

| Linux        | Windows      |
| ------------ | ------------ |
| `deactivate` | `deactivate` |

### Как работать с `pip`

Установить модуль из [PyPi](https://pypi.org/) (request)

```python
pip install <ИмяМодуля>
```

Установить модуль из образа `.whl` (Используется для тестирования модуля перед отправкой в PyPi)

```python
pip install <Путь.whl>
```

Удалить модуль

```python
pip uninstall <ИмяМодуля>
```

> Модули хранятся в `venv/lib/python3.9/site-packages`

---

Посмотреть информацию о модуле

```python
pip show  <ИмяМодуля>
```

---

Создать файл с зависимостями

```bash
рiр freeze > requirements.txt
```

Установить зависимости из файла

```bash
рiр install - r requirements.txt
```

---

## Закрепление:

### !

Создать и активировать виртуальное окружение через консоль.

# Тема 11 Система контроля версий. Git

## Теория:

Установка

| Ubuntu                 | Arch                 | Windows                                     |
| ---------------------- | -------------------- | ------------------------------------------- |
| `sudo apt install git` | `sudo pacman -S git` | [Скачать](https://git-scm.com/download/win) |

- `Untracked files` = Файлы которые НЕ отслеживается.
- `tracing files` = Файлы, которые отслеживаются
- `modified` = Измененные файлы.
- `Index` = Добавленные в индекс.
- `committed`

### Настройки

Настроить конфигурацию пользователя

```bush
git config --global user.name "<Your Name>"
git config --global user.email "<your_email@whatever.com>"
```

### Команды для Git

### Оснавные команды

Создать локальный git репозиторий

```bush
git init
```

---

Узнать состояние репозитория

```bush
git ststus
```

---

Добавить конкретный файл в отслеживание

```python
git add <Name>
```

Или добавить все файлы в отслеживание

```python
git add *
```

---

Записать изменения - Сделать `commit`

```bush
git commit -m "Сообщение"
```

---

Откатить _**modified**_ файл на прошлый Commit

```-
git restore <NameFile>
```

Откатить _**committed**_ файл на прошлый Commit

```-
git restore --staged <NameFile>
```

---

Создать удаленный репозиторий

```bush
git remote add <origin> <https://<user_name>:<token>@github.com/<user_name>/<Проект>>
```

Узнать какой url установлен в удаленном репозитории

```bush
git remote -v
```

Изменить URL у удаленного репозитория

```bush
git remote set-url <origin> <Новый_URL>
```

---

Push - Отправить данные на удаленный сервер

```bush
git push
```

> origin - это новое имя удаленно сервера
>
> master – имя втеки удаленного сервера

---

Pull - Получить данные из удаленного сервера

```python
git pull
```

Если возникнут конфликты коммитов при получении данных из удаленного сервера. То можно принудительно изменить текущую историю коммитов, на ту, которая находится в удаленном сервере.

```bush
git pull <origin> <master> --allow-unrelated-histories
```

### Работа с ветками

#### Навигация по веткам

Узнать текущую ветку

```bush
git branch
	* master - Выбранная ветка
	  test
```

Переключиться на другую ветку

```bush
git checkout <ИмяВетки>
```

---

Создать новую ветку

```bush
git branch <Name_Branch>
```

---

Удалить ветку – удалиться только если эта ветка соединена с другой – **безопасное** удаление

```bush
git branch -d <test>
```

Удалить ветку в **любом** случае

```bush
git branch -D <test>
```

#### Слияние веток Merge

1.  **Выбираем** ветку в которую нужно добавить код

    ```bush
    git checkout <LastBranch>
    ```

2.  Соединяем с **Новой веткой**

    ```bush
    git merge <NewBranch>
    ```

### .gitignore

В этом `.gitignore` нужно хранить пути к файлам которые вы не хотите отслеживать.

```bush
/Folder – вся папка игнорируеться
file.txt – файл игнорируеться
/Folder/file.png – вложенный файл игнорируретсья
```

Стандартное заполнение `.gitignore`

```bush
/.idea
/venv
/.git
```

## Закрепление:

### !

Посмотреть [Урок по Git](https://www.youtube.com/watch?v=SEvR78OhGtw)
